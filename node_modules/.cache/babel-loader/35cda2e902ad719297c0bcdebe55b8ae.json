{"ast":null,"code":"/// S2 Geometry functions\n// the regional scoreboard is based on a level 6 S2 Cell\n// - https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i22\n// at the time of writing there's no actual API for the intel map to retrieve scoreboard data,\n// but it's still useful to plot the score cells on the intel map\n// the S2 geometry is based on projecting the earth sphere onto a cube, with some scaling of face coordinates to\n// keep things close to approximate equal area for adjacent cells\n// to convert a lat,lng into a cell id:\n// - convert lat,lng to x,y,z\n// - convert x,y,z into face,u,v\n// - u,v scaled to s,t with quadratic formula\n// - s,t converted to integer i,j offsets\n// - i,j converted to a position along a Hubbert space-filling curve\n// - combine face,position to get the cell id\n//NOTE: compared to the google S2 geometry library, we vary from their code in the following ways\n// - cell IDs: they combine face and the hilbert curve position into a single 64 bit number. this gives efficient space\n//             and speed. javascript doesn't have appropriate data types, and speed is not cricical, so we use\n//             as [face,[bitpair,bitpair,...]] instead\n// - i,j: they always use 30 bits, adjusting as needed. we use 0 to (1<<level)-1 instead\n//        (so GetSizeIJ for a cell is always 1)\n(function (exports) {\n  'use strict';\n\n  var S2 = exports.S2 = {\n    L: {}\n  };\n\n  S2.L.LatLng = function (\n  /*Number*/\n  rawLat,\n  /*Number*/\n  rawLng,\n  /*Boolean*/\n  noWrap) {\n    var lat = parseFloat(rawLat, 10);\n    var lng = parseFloat(rawLng, 10);\n\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + rawLat + ', ' + rawLng + ')');\n    }\n\n    if (noWrap !== true) {\n      lat = Math.max(Math.min(lat, 90), -90); // clamp latitude into -90..90\n\n      lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180); // wrap longtitude into -180..180\n    }\n\n    return {\n      lat: lat,\n      lng: lng\n    };\n  };\n\n  S2.L.LatLng.DEG_TO_RAD = Math.PI / 180;\n  S2.L.LatLng.RAD_TO_DEG = 180 / Math.PI;\n  /*\n  S2.LatLngToXYZ = function(latLng) {\n    // http://stackoverflow.com/questions/8981943/lat-long-to-x-y-z-position-in-js-not-working\n    var lat = latLng.lat;\n    var lon = latLng.lng;\n    var DEG_TO_RAD = Math.PI / 180.0;\n  \n    var phi = lat * DEG_TO_RAD;\n    var theta = lon * DEG_TO_RAD;\n  \n    var cosLat = Math.cos(phi);\n    var sinLat = Math.sin(phi);\n    var cosLon = Math.cos(theta);\n    var sinLon = Math.sin(theta);\n    var rad = 500.0;\n  \n    return [\n      rad * cosLat * cosLon\n    , rad * cosLat * sinLon\n    , rad * sinLat\n    ];\n  };\n  */\n\n  S2.LatLngToXYZ = function (latLng) {\n    var d2r = S2.L.LatLng.DEG_TO_RAD;\n    var phi = latLng.lat * d2r;\n    var theta = latLng.lng * d2r;\n    var cosphi = Math.cos(phi);\n    return [Math.cos(theta) * cosphi, Math.sin(theta) * cosphi, Math.sin(phi)];\n  };\n\n  S2.XYZToLatLng = function (xyz) {\n    var r2d = S2.L.LatLng.RAD_TO_DEG;\n    var lat = Math.atan2(xyz[2], Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1]));\n    var lng = Math.atan2(xyz[1], xyz[0]);\n    return S2.L.LatLng(lat * r2d, lng * r2d);\n  };\n\n  var largestAbsComponent = function (xyz) {\n    var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];\n\n    if (temp[0] > temp[1]) {\n      if (temp[0] > temp[2]) {\n        return 0;\n      } else {\n        return 2;\n      }\n    } else {\n      if (temp[1] > temp[2]) {\n        return 1;\n      } else {\n        return 2;\n      }\n    }\n  };\n\n  var faceXYZToUV = function (face, xyz) {\n    var u, v;\n\n    switch (face) {\n      case 0:\n        u = xyz[1] / xyz[0];\n        v = xyz[2] / xyz[0];\n        break;\n\n      case 1:\n        u = -xyz[0] / xyz[1];\n        v = xyz[2] / xyz[1];\n        break;\n\n      case 2:\n        u = -xyz[0] / xyz[2];\n        v = -xyz[1] / xyz[2];\n        break;\n\n      case 3:\n        u = xyz[2] / xyz[0];\n        v = xyz[1] / xyz[0];\n        break;\n\n      case 4:\n        u = xyz[2] / xyz[1];\n        v = -xyz[0] / xyz[1];\n        break;\n\n      case 5:\n        u = -xyz[1] / xyz[2];\n        v = -xyz[0] / xyz[2];\n        break;\n\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n\n    return [u, v];\n  };\n\n  S2.XYZToFaceUV = function (xyz) {\n    var face = largestAbsComponent(xyz);\n\n    if (xyz[face] < 0) {\n      face += 3;\n    }\n\n    var uv = faceXYZToUV(face, xyz);\n    return [face, uv];\n  };\n\n  S2.FaceUVToXYZ = function (face, uv) {\n    var u = uv[0];\n    var v = uv[1];\n\n    switch (face) {\n      case 0:\n        return [1, u, v];\n\n      case 1:\n        return [-u, 1, v];\n\n      case 2:\n        return [-u, -v, 1];\n\n      case 3:\n        return [-1, -v, -u];\n\n      case 4:\n        return [v, -1, -u];\n\n      case 5:\n        return [v, u, -1];\n\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n  };\n\n  var singleSTtoUV = function (st) {\n    if (st >= 0.5) {\n      return 1 / 3.0 * (4 * st * st - 1);\n    } else {\n      return 1 / 3.0 * (1 - 4 * (1 - st) * (1 - st));\n    }\n  };\n\n  S2.STToUV = function (st) {\n    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n  };\n\n  var singleUVtoST = function (uv) {\n    if (uv >= 0) {\n      return 0.5 * Math.sqrt(1 + 3 * uv);\n    } else {\n      return 1 - 0.5 * Math.sqrt(1 - 3 * uv);\n    }\n  };\n\n  S2.UVToST = function (uv) {\n    return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];\n  };\n\n  S2.STToIJ = function (st, order) {\n    var maxSize = 1 << order;\n\n    var singleSTtoIJ = function (st) {\n      var ij = Math.floor(st * maxSize);\n      return Math.max(0, Math.min(maxSize - 1, ij));\n    };\n\n    return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];\n  };\n\n  S2.IJToST = function (ij, order, offsets) {\n    var maxSize = 1 << order;\n    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n  };\n\n  var rotateAndFlipQuadrant = function (n, point, rx, ry) {\n    var newX, newY;\n\n    if (ry == 0) {\n      if (rx == 1) {\n        point.x = n - 1 - point.x;\n        point.y = n - 1 - point.y;\n      }\n\n      var x = point.x;\n      point.x = point.y;\n      point.y = x;\n    }\n  }; // hilbert space-filling curve\n  // based on http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves\n  // note: rather then calculating the final integer hilbert position, we just return the list of quads\n  // this ensures no precision issues whth large orders (S3 cell IDs use up to 30), and is more\n  // convenient for pulling out the individual bits as needed later\n\n\n  var pointToHilbertQuadList = function (x, y, order, face) {\n    var hilbertMap = {\n      'a': [[0, 'd'], [1, 'a'], [3, 'b'], [2, 'a']],\n      'b': [[2, 'b'], [1, 'b'], [3, 'a'], [0, 'c']],\n      'c': [[2, 'c'], [3, 'd'], [1, 'c'], [0, 'b']],\n      'd': [[0, 'a'], [3, 'c'], [1, 'd'], [2, 'd']]\n    };\n\n    if ('number' !== typeof face) {\n      console.warn(new Error(\"called pointToHilbertQuadList without face value, defaulting to '0'\").stack);\n    }\n\n    var currentSquare = face % 2 ? 'd' : 'a';\n    var positions = [];\n\n    for (var i = order - 1; i >= 0; i--) {\n      var mask = 1 << i;\n      var quad_x = x & mask ? 1 : 0;\n      var quad_y = y & mask ? 1 : 0;\n      var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];\n      positions.push(t[0]);\n      currentSquare = t[1];\n    }\n\n    return positions;\n  }; // S2Cell class\n\n\n  S2.S2Cell = function () {};\n\n  S2.S2Cell.FromHilbertQuadKey = function (hilbertQuadkey) {\n    var parts = hilbertQuadkey.split('/');\n    var face = parseInt(parts[0]);\n    var position = parts[1];\n    var maxLevel = position.length;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var i;\n    var level;\n    var bit;\n    var rx, ry;\n    var val;\n\n    for (i = maxLevel - 1; i >= 0; i--) {\n      level = maxLevel - i;\n      bit = position[i];\n      rx = 0;\n      ry = 0;\n\n      if (bit === '1') {\n        ry = 1;\n      } else if (bit === '2') {\n        rx = 1;\n        ry = 1;\n      } else if (bit === '3') {\n        rx = 1;\n      }\n\n      val = Math.pow(2, level - 1);\n      rotateAndFlipQuadrant(val, point, rx, ry);\n      point.x += val * rx;\n      point.y += val * ry;\n    }\n\n    if (face % 2 === 1) {\n      var t = point.x;\n      point.x = point.y;\n      point.y = t;\n    }\n\n    return S2.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);\n  }; //static method to construct\n\n\n  S2.S2Cell.FromLatLng = function (latLng, level) {\n    if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {\n      throw new Error(\"Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng\");\n    }\n\n    var xyz = S2.LatLngToXYZ(latLng);\n    var faceuv = S2.XYZToFaceUV(xyz);\n    var st = S2.UVToST(faceuv[1]);\n    var ij = S2.STToIJ(st, level);\n    return S2.S2Cell.FromFaceIJ(faceuv[0], ij, level);\n  };\n  /*\n  S2.faceIjLevelToXyz = function (face, ij, level) {\n    var st = S2.IJToST(ij, level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(face, uv);\n  \n    return S2.XYZToLatLng(xyz);\n    return xyz;\n  };\n  */\n\n\n  S2.S2Cell.FromFaceIJ = function (face, ij, level) {\n    var cell = new S2.S2Cell();\n    cell.face = face;\n    cell.ij = ij;\n    cell.level = level;\n    return cell;\n  };\n\n  S2.S2Cell.prototype.toString = function () {\n    return 'F' + this.face + 'ij[' + this.ij[0] + ',' + this.ij[1] + ']@' + this.level;\n  };\n\n  S2.S2Cell.prototype.getLatLng = function () {\n    var st = S2.IJToST(this.ij, this.level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(this.face, uv);\n    return S2.XYZToLatLng(xyz);\n  };\n\n  S2.S2Cell.prototype.getCornerLatLngs = function () {\n    var result = [];\n    var offsets = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]];\n\n    for (var i = 0; i < 4; i++) {\n      var st = S2.IJToST(this.ij, this.level, offsets[i]);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(this.face, uv);\n      result.push(S2.XYZToLatLng(xyz));\n    }\n\n    return result;\n  };\n\n  S2.S2Cell.prototype.getFaceAndQuads = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return [this.face, quads];\n  };\n\n  S2.S2Cell.prototype.toHilbertQuadkey = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return this.face.toString(10) + '/' + quads.join('');\n  };\n\n  S2.latLngToNeighborKeys = S2.S2Cell.latLngToNeighborKeys = function (lat, lng, level) {\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).getNeighbors().map(function (cell) {\n      return cell.toHilbertQuadkey();\n    });\n  };\n\n  S2.S2Cell.prototype.getNeighbors = function () {\n    var fromFaceIJWrap = function (face, ij, level) {\n      var maxSize = 1 << level;\n\n      if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {\n        // no wrapping out of bounds\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      } else {\n        // the new i,j are out of range.\n        // with the assumption that they're only a little past the borders we can just take the points as\n        // just beyond the cube face, project to XYZ, then re-create FaceUV from the XYZ vector\n        var st = S2.IJToST(ij, level, [0.5, 0.5]);\n        var uv = S2.STToUV(st);\n        var xyz = S2.FaceUVToXYZ(face, uv);\n        var faceuv = S2.XYZToFaceUV(xyz);\n        face = faceuv[0];\n        uv = faceuv[1];\n        st = S2.UVToST(uv);\n        ij = S2.STToIJ(st, level);\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      }\n    };\n\n    var face = this.face;\n    var i = this.ij[0];\n    var j = this.ij[1];\n    var level = this.level;\n    return [fromFaceIJWrap(face, [i - 1, j], level), fromFaceIJWrap(face, [i, j - 1], level), fromFaceIJWrap(face, [i + 1, j], level), fromFaceIJWrap(face, [i, j + 1], level)];\n  }; //\n  // Functional Style\n  //\n\n\n  S2.FACE_BITS = 3;\n  S2.MAX_LEVEL = 30;\n  S2.POS_BITS = 2 * S2.MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\n\n  S2.facePosLevelToId = S2.S2Cell.facePosLevelToId = S2.fromFacePosLevel = function (faceN, posS, levelN) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var faceB;\n    var posB;\n    var bin;\n\n    if (!levelN) {\n      levelN = posS.length;\n    }\n\n    if (posS.length > levelN) {\n      posS = posS.substr(0, levelN);\n    } // 3-bit face value\n\n\n    faceB = Long.fromString(faceN.toString(10), true, 10).toString(2);\n\n    while (faceB.length < S2.FACE_BITS) {\n      faceB = '0' + faceB;\n    } // 60-bit position value\n\n\n    posB = Long.fromString(posS, true, 4).toString(2);\n\n    while (posB.length < 2 * levelN) {\n      posB = '0' + posB;\n    }\n\n    bin = faceB + posB; // 1-bit lsb marker\n\n    bin += '1'; // n-bit padding to 64-bits\n\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin += '0';\n    }\n\n    return Long.fromString(bin, true, 2).toString(10);\n  };\n\n  S2.keyToId = S2.S2Cell.keyToId = S2.toId = S2.toCellId = S2.fromKey = function (key) {\n    var parts = key.split('/');\n    return S2.fromFacePosLevel(parts[0], parts[1], parts[1].length);\n  };\n\n  S2.idToKey = S2.S2Cell.idToKey = S2.S2Cell.toKey = S2.toKey = S2.fromId = S2.fromCellId = S2.S2Cell.toHilbertQuadkey = S2.toHilbertQuadkey = function (idS) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var bin = Long.fromString(idS, true, 10).toString(2);\n\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin = '0' + bin;\n    } // MUST come AFTER binstr has been left-padded with '0's\n\n\n    var lsbIndex = bin.lastIndexOf('1'); // substr(start, len)\n    // substring(start, end) // includes start, does not include end\n\n    var faceB = bin.substring(0, 3); // posB will always be a multiple of 2 (or it's invalid)\n\n    var posB = bin.substring(3, lsbIndex);\n    var levelN = posB.length / 2;\n    var faceS = Long.fromString(faceB, true, 2).toString(10);\n    var posS = Long.fromString(posB, true, 2).toString(4);\n\n    while (posS.length < levelN) {\n      posS = '0' + posS;\n    }\n\n    return faceS + '/' + posS;\n  };\n\n  S2.keyToLatLng = S2.S2Cell.keyToLatLng = function (key) {\n    var cell2 = S2.S2Cell.FromHilbertQuadKey(key);\n    return cell2.getLatLng();\n  };\n\n  S2.idToLatLng = S2.S2Cell.idToLatLng = function (id) {\n    var key = S2.idToKey(id);\n    return S2.keyToLatLng(key);\n  };\n\n  S2.S2Cell.latLngToKey = S2.latLngToKey = S2.latLngToQuadkey = function (lat, lng, level) {\n    if (isNaN(level) || level < 1 || level > 30) {\n      throw new Error(\"'level' is not a number between 1 and 30 (but it should be)\");\n    } // TODO\n    //\n    // S2.idToLatLng(id)\n    // S2.keyToLatLng(key)\n    // S2.nextFace(key)     // prevent wrapping on nextKey\n    // S2.prevFace(key)     // prevent wrapping on prevKey\n    //\n    // .toKeyArray(id)  // face,quadtree\n    // .toKey(id)       // hilbert\n    // .toPoint(id)     // ij\n    // .toId(key)       // uint64 (as string)\n    // .toLong(key)     // long.js\n    // .toLatLng(id)    // object? or array?, or string (with comma)?\n    //\n    // maybe S2.HQ.x, S2.GPS.x, S2.CI.x?\n\n\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).toHilbertQuadkey();\n  };\n\n  S2.stepKey = function (key, num) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var parts = key.split('/');\n    var faceS = parts[0];\n    var posS = parts[1];\n    var level = parts[1].length;\n    var posL = Long.fromString(posS, true, 4); // TODO handle wrapping (0 === pos + 1)\n    // (only on the 12 edges of the globe)\n\n    var otherL;\n\n    if (num > 0) {\n      otherL = posL.add(Math.abs(num));\n    } else if (num < 0) {\n      otherL = posL.subtract(Math.abs(num));\n    }\n\n    var otherS = otherL.toString(4);\n\n    if ('0' === otherS) {\n      console.warning(new Error(\"face/position wrapping is not yet supported\"));\n    }\n\n    while (otherS.length < level) {\n      otherS = '0' + otherS;\n    }\n\n    return faceS + '/' + otherS;\n  };\n\n  S2.S2Cell.prevKey = S2.prevKey = function (key) {\n    return S2.stepKey(key, -1);\n  };\n\n  S2.S2Cell.nextKey = S2.nextKey = function (key) {\n    return S2.stepKey(key, 1);\n  };\n})('undefined' !== typeof module ? module.exports : window);","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/s2-geometry/src/s2geometry.js"],"names":["exports","S2","L","LatLng","rawLat","rawLng","noWrap","lat","parseFloat","lng","isNaN","Error","Math","max","min","DEG_TO_RAD","PI","RAD_TO_DEG","LatLngToXYZ","latLng","d2r","phi","theta","cosphi","cos","sin","XYZToLatLng","xyz","r2d","atan2","sqrt","largestAbsComponent","temp","abs","faceXYZToUV","face","u","v","error","XYZToFaceUV","uv","FaceUVToXYZ","singleSTtoUV","st","STToUV","singleUVtoST","UVToST","STToIJ","order","maxSize","singleSTtoIJ","ij","floor","IJToST","offsets","rotateAndFlipQuadrant","n","point","rx","ry","newX","newY","x","y","pointToHilbertQuadList","hilbertMap","console","warn","stack","currentSquare","positions","i","mask","quad_x","quad_y","t","push","S2Cell","FromHilbertQuadKey","hilbertQuadkey","parts","split","parseInt","position","maxLevel","length","level","bit","val","pow","FromFaceIJ","FromLatLng","faceuv","cell","prototype","toString","getLatLng","getCornerLatLngs","result","getFaceAndQuads","quads","toHilbertQuadkey","join","latLngToNeighborKeys","getNeighbors","map","fromFaceIJWrap","j","FACE_BITS","MAX_LEVEL","POS_BITS","facePosLevelToId","fromFacePosLevel","faceN","posS","levelN","Long","dcodeIO","require","faceB","posB","bin","substr","fromString","keyToId","toId","toCellId","fromKey","key","idToKey","toKey","fromId","fromCellId","idS","lsbIndex","lastIndexOf","substring","faceS","keyToLatLng","cell2","idToLatLng","id","latLngToKey","latLngToQuadkey","stepKey","num","posL","otherL","add","subtract","otherS","warning","prevKey","nextKey","module","window"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC,UAAUA,OAAV,EAAmB;AACpB;;AAEA,MAAIC,EAAE,GAAGD,OAAO,CAACC,EAAR,GAAa;AAAEC,IAAAA,CAAC,EAAE;AAAL,GAAtB;;AAEAD,EAAAA,EAAE,CAACC,CAAH,CAAKC,MAAL,GAAc;AAAU;AAAWC,EAAAA,MAArB;AAA6B;AAAWC,EAAAA,MAAxC;AAAgD;AAAYC,EAAAA,MAA5D,EAAoE;AAChF,QAAIC,GAAG,GAAGC,UAAU,CAACJ,MAAD,EAAS,EAAT,CAApB;AACA,QAAIK,GAAG,GAAGD,UAAU,CAACH,MAAD,EAAS,EAAT,CAApB;;AAEA,QAAIK,KAAK,CAACH,GAAD,CAAL,IAAcG,KAAK,CAACD,GAAD,CAAvB,EAA8B;AAC5B,YAAM,IAAIE,KAAJ,CAAU,6BAA6BP,MAA7B,GAAsC,IAAtC,GAA6CC,MAA7C,GAAsD,GAAhE,CAAN;AACD;;AAED,QAAIC,MAAM,KAAK,IAAf,EAAqB;AACnBC,MAAAA,GAAG,GAAGK,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASP,GAAT,EAAc,EAAd,CAAT,EAA4B,CAAC,EAA7B,CAAN,CADmB,CACqC;;AACxDE,MAAAA,GAAG,GAAG,CAACA,GAAG,GAAG,GAAP,IAAc,GAAd,IAAsBA,GAAG,GAAG,CAAC,GAAP,IAAcA,GAAG,KAAK,GAAvB,GAA8B,GAA9B,GAAoC,CAAC,GAA1D,CAAN,CAFmB,CAEqD;AACzE;;AAED,WAAO;AAAEF,MAAAA,GAAG,EAAEA,GAAP;AAAYE,MAAAA,GAAG,EAAEA;AAAjB,KAAP;AACD,GAdD;;AAgBAR,EAAAA,EAAE,CAACC,CAAH,CAAKC,MAAL,CAAYY,UAAZ,GAAyBH,IAAI,CAACI,EAAL,GAAU,GAAnC;AACAf,EAAAA,EAAE,CAACC,CAAH,CAAKC,MAAL,CAAYc,UAAZ,GAAyB,MAAML,IAAI,CAACI,EAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAf,EAAAA,EAAE,CAACiB,WAAH,GAAiB,UAASC,MAAT,EAAiB;AAChC,QAAIC,GAAG,GAAGnB,EAAE,CAACC,CAAH,CAAKC,MAAL,CAAYY,UAAtB;AAEA,QAAIM,GAAG,GAAGF,MAAM,CAACZ,GAAP,GAAWa,GAArB;AACA,QAAIE,KAAK,GAAGH,MAAM,CAACV,GAAP,GAAWW,GAAvB;AAEA,QAAIG,MAAM,GAAGX,IAAI,CAACY,GAAL,CAASH,GAAT,CAAb;AAEA,WAAO,CAACT,IAAI,CAACY,GAAL,CAASF,KAAT,IAAgBC,MAAjB,EAAyBX,IAAI,CAACa,GAAL,CAASH,KAAT,IAAgBC,MAAzC,EAAiDX,IAAI,CAACa,GAAL,CAASJ,GAAT,CAAjD,CAAP;AACD,GATD;;AAWApB,EAAAA,EAAE,CAACyB,WAAH,GAAiB,UAASC,GAAT,EAAc;AAC7B,QAAIC,GAAG,GAAG3B,EAAE,CAACC,CAAH,CAAKC,MAAL,CAAYc,UAAtB;AAEA,QAAIV,GAAG,GAAGK,IAAI,CAACiB,KAAL,CAAWF,GAAG,CAAC,CAAD,CAAd,EAAmBf,IAAI,CAACkB,IAAL,CAAUH,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAV,GAAcA,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAlC,CAAnB,CAAV;AACA,QAAIlB,GAAG,GAAGG,IAAI,CAACiB,KAAL,CAAWF,GAAG,CAAC,CAAD,CAAd,EAAmBA,GAAG,CAAC,CAAD,CAAtB,CAAV;AAEA,WAAO1B,EAAE,CAACC,CAAH,CAAKC,MAAL,CAAYI,GAAG,GAACqB,GAAhB,EAAqBnB,GAAG,GAACmB,GAAzB,CAAP;AACD,GAPD;;AASA,MAAIG,mBAAmB,GAAG,UAASJ,GAAT,EAAc;AACtC,QAAIK,IAAI,GAAG,CAACpB,IAAI,CAACqB,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,CAAD,EAAmBf,IAAI,CAACqB,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,CAAnB,EAAqCf,IAAI,CAACqB,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,CAArC,CAAX;;AAEA,QAAIK,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlB,EAAuB;AACrB,UAAIA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlB,EAAuB;AACrB,eAAO,CAAP;AACD,OAFD,MAEO;AACL,eAAO,CAAP;AACD;AACF,KAND,MAMO;AACL,UAAIA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlB,EAAuB;AACrB,eAAO,CAAP;AACD,OAFD,MAEO;AACL,eAAO,CAAP;AACD;AACF;AAEF,GAjBD;;AAmBA,MAAIE,WAAW,GAAG,UAASC,IAAT,EAAcR,GAAd,EAAmB;AACnC,QAAIS,CAAJ,EAAMC,CAAN;;AAEA,YAAQF,IAAR;AACE,WAAK,CAAL;AAAQC,QAAAA,CAAC,GAAIT,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAIV,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD,WAAK,CAAL;AAAQS,QAAAA,CAAC,GAAG,CAACT,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAIV,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD,WAAK,CAAL;AAAQS,QAAAA,CAAC,GAAG,CAACT,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAG,CAACV,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD,WAAK,CAAL;AAAQS,QAAAA,CAAC,GAAIT,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAIV,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD,WAAK,CAAL;AAAQS,QAAAA,CAAC,GAAIT,GAAG,CAAC,CAAD,CAAH,GAAOA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAG,CAACV,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD,WAAK,CAAL;AAAQS,QAAAA,CAAC,GAAG,CAACT,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoBU,QAAAA,CAAC,GAAG,CAACV,GAAG,CAAC,CAAD,CAAJ,GAAQA,GAAG,CAAC,CAAD,CAAf;AAAoB;;AAChD;AAAS,cAAM;AAACW,UAAAA,KAAK,EAAE;AAAR,SAAN;AAPX;;AAUA,WAAO,CAACF,CAAD,EAAGC,CAAH,CAAP;AACD,GAdD;;AAmBApC,EAAAA,EAAE,CAACsC,WAAH,GAAiB,UAASZ,GAAT,EAAc;AAC7B,QAAIQ,IAAI,GAAGJ,mBAAmB,CAACJ,GAAD,CAA9B;;AAEA,QAAIA,GAAG,CAACQ,IAAD,CAAH,GAAY,CAAhB,EAAmB;AACjBA,MAAAA,IAAI,IAAI,CAAR;AACD;;AAED,QAAIK,EAAE,GAAGN,WAAW,CAAEC,IAAF,EAAOR,GAAP,CAApB;AAEA,WAAO,CAACQ,IAAD,EAAOK,EAAP,CAAP;AACD,GAVD;;AAYAvC,EAAAA,EAAE,CAACwC,WAAH,GAAiB,UAASN,IAAT,EAAcK,EAAd,EAAkB;AACjC,QAAIJ,CAAC,GAAGI,EAAE,CAAC,CAAD,CAAV;AACA,QAAIH,CAAC,GAAGG,EAAE,CAAC,CAAD,CAAV;;AAEA,YAAQL,IAAR;AACE,WAAK,CAAL;AAAQ,eAAO,CAAE,CAAF,EAAKC,CAAL,EAAQC,CAAR,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAO,CAAC,CAACD,CAAF,EAAK,CAAL,EAAQC,CAAR,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAO,CAAC,CAACD,CAAF,EAAI,CAACC,CAAL,EAAQ,CAAR,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAO,CAAC,CAAC,CAAF,EAAI,CAACA,CAAL,EAAO,CAACD,CAAR,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAO,CAAEC,CAAF,EAAI,CAAC,CAAL,EAAO,CAACD,CAAR,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAO,CAAEC,CAAF,EAAKD,CAAL,EAAO,CAAC,CAAR,CAAP;;AACR;AAAS,cAAM;AAACE,UAAAA,KAAK,EAAE;AAAR,SAAN;AAPX;AASD,GAbD;;AAeA,MAAII,YAAY,GAAG,UAASC,EAAT,EAAa;AAC9B,QAAIA,EAAE,IAAI,GAAV,EAAe;AACb,aAAQ,IAAE,GAAH,IAAW,IAAEA,EAAF,GAAKA,EAAL,GAAU,CAArB,CAAP;AACD,KAFD,MAEO;AACL,aAAQ,IAAE,GAAH,IAAW,IAAK,KAAG,IAAEA,EAAL,KAAU,IAAEA,EAAZ,CAAhB,CAAP;AACD;AACF,GAND;;AAQA1C,EAAAA,EAAE,CAAC2C,MAAH,GAAY,UAASD,EAAT,EAAa;AACvB,WAAO,CAACD,YAAY,CAACC,EAAE,CAAC,CAAD,CAAH,CAAb,EAAsBD,YAAY,CAACC,EAAE,CAAC,CAAD,CAAH,CAAlC,CAAP;AACD,GAFD;;AAKA,MAAIE,YAAY,GAAG,UAASL,EAAT,EAAa;AAC9B,QAAIA,EAAE,IAAI,CAAV,EAAa;AACX,aAAO,MAAM5B,IAAI,CAACkB,IAAL,CAAW,IAAI,IAAEU,EAAjB,CAAb;AACD,KAFD,MAEO;AACL,aAAO,IAAI,MAAM5B,IAAI,CAACkB,IAAL,CAAW,IAAI,IAAEU,EAAjB,CAAjB;AACD;AACF,GAND;;AAOAvC,EAAAA,EAAE,CAAC6C,MAAH,GAAY,UAASN,EAAT,EAAa;AACvB,WAAO,CAACK,YAAY,CAACL,EAAE,CAAC,CAAD,CAAH,CAAb,EAAsBK,YAAY,CAACL,EAAE,CAAC,CAAD,CAAH,CAAlC,CAAP;AACD,GAFD;;AAKAvC,EAAAA,EAAE,CAAC8C,MAAH,GAAY,UAASJ,EAAT,EAAYK,KAAZ,EAAmB;AAC7B,QAAIC,OAAO,GAAI,KAAGD,KAAlB;;AAEA,QAAIE,YAAY,GAAG,UAASP,EAAT,EAAa;AAC9B,UAAIQ,EAAE,GAAGvC,IAAI,CAACwC,KAAL,CAAWT,EAAE,GAAGM,OAAhB,CAAT;AACA,aAAOrC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,GAAL,CAASmC,OAAO,GAAC,CAAjB,EAAoBE,EAApB,CAAZ,CAAP;AACD,KAHD;;AAKA,WAAO,CAACD,YAAY,CAACP,EAAE,CAAC,CAAD,CAAH,CAAb,EAAsBO,YAAY,CAACP,EAAE,CAAC,CAAD,CAAH,CAAlC,CAAP;AACD,GATD;;AAYA1C,EAAAA,EAAE,CAACoD,MAAH,GAAY,UAASF,EAAT,EAAYH,KAAZ,EAAkBM,OAAlB,EAA2B;AACrC,QAAIL,OAAO,GAAI,KAAGD,KAAlB;AAEA,WAAO,CACL,CAACG,EAAE,CAAC,CAAD,CAAF,GAAMG,OAAO,CAAC,CAAD,CAAd,IAAmBL,OADd,EAEL,CAACE,EAAE,CAAC,CAAD,CAAF,GAAMG,OAAO,CAAC,CAAD,CAAd,IAAmBL,OAFd,CAAP;AAID,GAPD;;AAWA,MAAIM,qBAAqB,GAAG,UAASC,CAAT,EAAYC,KAAZ,EAAmBC,EAAnB,EAAuBC,EAAvB,EAC5B;AACC,QAAIC,IAAJ,EAAUC,IAAV;;AACA,QAAGF,EAAE,IAAI,CAAT,EACA;AACC,UAAGD,EAAE,IAAI,CAAT,EAAW;AACVD,QAAAA,KAAK,CAACK,CAAN,GAAUN,CAAC,GAAG,CAAJ,GAAQC,KAAK,CAACK,CAAxB;AACAL,QAAAA,KAAK,CAACM,CAAN,GAAUP,CAAC,GAAG,CAAJ,GAAQC,KAAK,CAACM,CAAxB;AAEA;;AAEC,UAAID,CAAC,GAAGL,KAAK,CAACK,CAAd;AACFL,MAAAA,KAAK,CAACK,CAAN,GAAUL,KAAK,CAACM,CAAhB;AACAN,MAAAA,KAAK,CAACM,CAAN,GAAUD,CAAV;AACA;AAED,GAhBD,CApLoB,CA0MpB;AACA;AACA;AACA;AACA;;;AACA,MAAIE,sBAAsB,GAAG,UAASF,CAAT,EAAWC,CAAX,EAAaf,KAAb,EAAmBb,IAAnB,EAAyB;AACpD,QAAI8B,UAAU,GAAG;AACf,WAAK,CAAE,CAAC,CAAD,EAAG,GAAH,CAAF,EAAW,CAAC,CAAD,EAAG,GAAH,CAAX,EAAoB,CAAC,CAAD,EAAG,GAAH,CAApB,EAA6B,CAAC,CAAD,EAAG,GAAH,CAA7B,CADU;AAEf,WAAK,CAAE,CAAC,CAAD,EAAG,GAAH,CAAF,EAAW,CAAC,CAAD,EAAG,GAAH,CAAX,EAAoB,CAAC,CAAD,EAAG,GAAH,CAApB,EAA6B,CAAC,CAAD,EAAG,GAAH,CAA7B,CAFU;AAGf,WAAK,CAAE,CAAC,CAAD,EAAG,GAAH,CAAF,EAAW,CAAC,CAAD,EAAG,GAAH,CAAX,EAAoB,CAAC,CAAD,EAAG,GAAH,CAApB,EAA6B,CAAC,CAAD,EAAG,GAAH,CAA7B,CAHU;AAIf,WAAK,CAAE,CAAC,CAAD,EAAG,GAAH,CAAF,EAAW,CAAC,CAAD,EAAG,GAAH,CAAX,EAAoB,CAAC,CAAD,EAAG,GAAH,CAApB,EAA6B,CAAC,CAAD,EAAG,GAAH,CAA7B;AAJU,KAAjB;;AAOA,QAAI,aAAa,OAAO9B,IAAxB,EAA8B;AAC5B+B,MAAAA,OAAO,CAACC,IAAR,CAAa,IAAIxD,KAAJ,CAAU,qEAAV,EAAiFyD,KAA9F;AACD;;AACD,QAAIC,aAAa,GAAIlC,IAAI,GAAG,CAAR,GAAa,GAAb,GAAmB,GAAvC;AACA,QAAImC,SAAS,GAAG,EAAhB;;AAEA,SAAK,IAAIC,CAAC,GAACvB,KAAK,GAAC,CAAjB,EAAoBuB,CAAC,IAAE,CAAvB,EAA0BA,CAAC,EAA3B,EAA+B;AAE7B,UAAIC,IAAI,GAAG,KAAGD,CAAd;AAEA,UAAIE,MAAM,GAAGX,CAAC,GAACU,IAAF,GAAS,CAAT,GAAa,CAA1B;AACA,UAAIE,MAAM,GAAGX,CAAC,GAACS,IAAF,GAAS,CAAT,GAAa,CAA1B;AAEA,UAAIG,CAAC,GAAGV,UAAU,CAACI,aAAD,CAAV,CAA0BI,MAAM,GAAC,CAAP,GAASC,MAAnC,CAAR;AAEAJ,MAAAA,SAAS,CAACM,IAAV,CAAeD,CAAC,CAAC,CAAD,CAAhB;AAEAN,MAAAA,aAAa,GAAGM,CAAC,CAAC,CAAD,CAAjB;AACD;;AAED,WAAOL,SAAP;AACD,GA7BD,CA/MoB,CA8OpB;;;AAEArE,EAAAA,EAAE,CAAC4E,MAAH,GAAY,YAAU,CAAE,CAAxB;;AAEA5E,EAAAA,EAAE,CAAC4E,MAAH,CAAUC,kBAAV,GAA+B,UAASC,cAAT,EAAyB;AACtD,QAAIC,KAAK,GAAGD,cAAc,CAACE,KAAf,CAAqB,GAArB,CAAZ;AACA,QAAI9C,IAAI,GAAG+C,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAAnB;AACA,QAAIG,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAApB;AACA,QAAII,QAAQ,GAAGD,QAAQ,CAACE,MAAxB;AACA,QAAI5B,KAAK,GAAG;AACVK,MAAAA,CAAC,EAAG,CADM;AAEVC,MAAAA,CAAC,EAAE;AAFO,KAAZ;AAIA,QAAIQ,CAAJ;AACA,QAAIe,KAAJ;AACA,QAAIC,GAAJ;AACA,QAAI7B,EAAJ,EAAQC,EAAR;AACA,QAAI6B,GAAJ;;AAED,SAAIjB,CAAC,GAAGa,QAAQ,GAAG,CAAnB,EAAsBb,CAAC,IAAI,CAA3B,EAA8BA,CAAC,EAA/B,EAAmC;AAElCe,MAAAA,KAAK,GAAGF,QAAQ,GAAGb,CAAnB;AACAgB,MAAAA,GAAG,GAAGJ,QAAQ,CAACZ,CAAD,CAAd;AACAb,MAAAA,EAAE,GAAG,CAAL;AACEC,MAAAA,EAAE,GAAG,CAAL;;AACF,UAAI4B,GAAG,KAAK,GAAZ,EAAiB;AAChB5B,QAAAA,EAAE,GAAG,CAAL;AACA,OAFD,MAGK,IAAI4B,GAAG,KAAK,GAAZ,EAAiB;AACrB7B,QAAAA,EAAE,GAAG,CAAL;AACAC,QAAAA,EAAE,GAAG,CAAL;AACA,OAHI,MAIA,IAAI4B,GAAG,KAAK,GAAZ,EAAiB;AACrB7B,QAAAA,EAAE,GAAG,CAAL;AACA;;AAED8B,MAAAA,GAAG,GAAG5E,IAAI,CAAC6E,GAAL,CAAS,CAAT,EAAYH,KAAK,GAAG,CAApB,CAAN;AACA/B,MAAAA,qBAAqB,CAACiC,GAAD,EAAM/B,KAAN,EAAaC,EAAb,EAAiBC,EAAjB,CAArB;AAEAF,MAAAA,KAAK,CAACK,CAAN,IAAW0B,GAAG,GAAG9B,EAAjB;AACAD,MAAAA,KAAK,CAACM,CAAN,IAAWyB,GAAG,GAAG7B,EAAjB;AAEA;;AAEA,QAAIxB,IAAI,GAAG,CAAP,KAAa,CAAjB,EAAoB;AAClB,UAAIwC,CAAC,GAAGlB,KAAK,CAACK,CAAd;AACAL,MAAAA,KAAK,CAACK,CAAN,GAAUL,KAAK,CAACM,CAAhB;AACAN,MAAAA,KAAK,CAACM,CAAN,GAAUY,CAAV;AACD;;AAGD,WAAO1E,EAAE,CAAC4E,MAAH,CAAUa,UAAV,CAAqBR,QAAQ,CAAC/C,IAAD,CAA7B,EAAqC,CAACsB,KAAK,CAACK,CAAP,EAAUL,KAAK,CAACM,CAAhB,CAArC,EAAyDuB,KAAzD,CAAP;AACD,GAhDD,CAlPoB,CAoSpB;;;AACArF,EAAAA,EAAE,CAAC4E,MAAH,CAAUc,UAAV,GAAuB,UAASxE,MAAT,EAAiBmE,KAAjB,EAAwB;AAC7C,QAAK,CAACnE,MAAM,CAACZ,GAAR,IAAeY,MAAM,CAACZ,GAAP,KAAe,CAA/B,IAAsC,CAACY,MAAM,CAACV,GAAR,IAAeU,MAAM,CAACV,GAAP,KAAe,CAAxE,EAA4E;AAC1E,YAAM,IAAIE,KAAJ,CAAU,qDAAV,CAAN;AACD;;AACD,QAAIgB,GAAG,GAAG1B,EAAE,CAACiB,WAAH,CAAeC,MAAf,CAAV;AAEA,QAAIyE,MAAM,GAAG3F,EAAE,CAACsC,WAAH,CAAeZ,GAAf,CAAb;AACA,QAAIgB,EAAE,GAAG1C,EAAE,CAAC6C,MAAH,CAAU8C,MAAM,CAAC,CAAD,CAAhB,CAAT;AAEA,QAAIzC,EAAE,GAAGlD,EAAE,CAAC8C,MAAH,CAAUJ,EAAV,EAAa2C,KAAb,CAAT;AAEA,WAAOrF,EAAE,CAAC4E,MAAH,CAAUa,UAAV,CAAsBE,MAAM,CAAC,CAAD,CAA5B,EAAiCzC,EAAjC,EAAqCmC,KAArC,CAAP;AACD,GAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEArF,EAAAA,EAAE,CAAC4E,MAAH,CAAUa,UAAV,GAAuB,UAASvD,IAAT,EAAcgB,EAAd,EAAiBmC,KAAjB,EAAwB;AAC7C,QAAIO,IAAI,GAAG,IAAI5F,EAAE,CAAC4E,MAAP,EAAX;AACAgB,IAAAA,IAAI,CAAC1D,IAAL,GAAYA,IAAZ;AACA0D,IAAAA,IAAI,CAAC1C,EAAL,GAAUA,EAAV;AACA0C,IAAAA,IAAI,CAACP,KAAL,GAAaA,KAAb;AAEA,WAAOO,IAAP;AACD,GAPD;;AAUA5F,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBC,QAApB,GAA+B,YAAW;AACxC,WAAO,MAAI,KAAK5D,IAAT,GAAc,KAAd,GAAoB,KAAKgB,EAAL,CAAQ,CAAR,CAApB,GAA+B,GAA/B,GAAmC,KAAKA,EAAL,CAAQ,CAAR,CAAnC,GAA8C,IAA9C,GAAmD,KAAKmC,KAA/D;AACD,GAFD;;AAIArF,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBE,SAApB,GAAgC,YAAW;AACzC,QAAIrD,EAAE,GAAG1C,EAAE,CAACoD,MAAH,CAAU,KAAKF,EAAf,EAAkB,KAAKmC,KAAvB,EAA8B,CAAC,GAAD,EAAK,GAAL,CAA9B,CAAT;AACA,QAAI9C,EAAE,GAAGvC,EAAE,CAAC2C,MAAH,CAAUD,EAAV,CAAT;AACA,QAAIhB,GAAG,GAAG1B,EAAE,CAACwC,WAAH,CAAe,KAAKN,IAApB,EAA0BK,EAA1B,CAAV;AAEA,WAAOvC,EAAE,CAACyB,WAAH,CAAeC,GAAf,CAAP;AACD,GAND;;AAQA1B,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBG,gBAApB,GAAuC,YAAW;AAChD,QAAIC,MAAM,GAAG,EAAb;AACA,QAAI5C,OAAO,GAAG,CACZ,CAAE,GAAF,EAAO,GAAP,CADY,EAEZ,CAAE,GAAF,EAAO,GAAP,CAFY,EAGZ,CAAE,GAAF,EAAO,GAAP,CAHY,EAIZ,CAAE,GAAF,EAAO,GAAP,CAJY,CAAd;;AAOA,SAAK,IAAIiB,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAC,CAAhB,EAAmBA,CAAC,EAApB,EAAwB;AACtB,UAAI5B,EAAE,GAAG1C,EAAE,CAACoD,MAAH,CAAU,KAAKF,EAAf,EAAmB,KAAKmC,KAAxB,EAA+BhC,OAAO,CAACiB,CAAD,CAAtC,CAAT;AACA,UAAI/B,EAAE,GAAGvC,EAAE,CAAC2C,MAAH,CAAUD,EAAV,CAAT;AACA,UAAIhB,GAAG,GAAG1B,EAAE,CAACwC,WAAH,CAAe,KAAKN,IAApB,EAA0BK,EAA1B,CAAV;AAEA0D,MAAAA,MAAM,CAACtB,IAAP,CAAc3E,EAAE,CAACyB,WAAH,CAAeC,GAAf,CAAd;AACD;;AACD,WAAOuE,MAAP;AACD,GAjBD;;AAoBAjG,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBK,eAApB,GAAsC,YAAY;AAChD,QAAIC,KAAK,GAAGpC,sBAAsB,CAAC,KAAKb,EAAL,CAAQ,CAAR,CAAD,EAAa,KAAKA,EAAL,CAAQ,CAAR,CAAb,EAAyB,KAAKmC,KAA9B,EAAqC,KAAKnD,IAA1C,CAAlC;AAEA,WAAO,CAAC,KAAKA,IAAN,EAAWiE,KAAX,CAAP;AACD,GAJD;;AAKAnG,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBO,gBAApB,GAAuC,YAAY;AACjD,QAAID,KAAK,GAAGpC,sBAAsB,CAAC,KAAKb,EAAL,CAAQ,CAAR,CAAD,EAAa,KAAKA,EAAL,CAAQ,CAAR,CAAb,EAAyB,KAAKmC,KAA9B,EAAqC,KAAKnD,IAA1C,CAAlC;AAEA,WAAO,KAAKA,IAAL,CAAU4D,QAAV,CAAmB,EAAnB,IAAyB,GAAzB,GAA+BK,KAAK,CAACE,IAAN,CAAW,EAAX,CAAtC;AACD,GAJD;;AAMArG,EAAAA,EAAE,CAACsG,oBAAH,GAA0BtG,EAAE,CAAC4E,MAAH,CAAU0B,oBAAV,GAAiC,UAAUhG,GAAV,EAAeE,GAAf,EAAoB6E,KAApB,EAA2B;AACpF,WAAOrF,EAAE,CAAC4E,MAAH,CAAUc,UAAV,CAAqB;AAAEpF,MAAAA,GAAG,EAAEA,GAAP;AAAYE,MAAAA,GAAG,EAAEA;AAAjB,KAArB,EAA6C6E,KAA7C,EAAoDkB,YAApD,GAAmEC,GAAnE,CAAuE,UAAUZ,IAAV,EAAgB;AAC5F,aAAOA,IAAI,CAACQ,gBAAL,EAAP;AACD,KAFM,CAAP;AAGD,GAJD;;AAKApG,EAAAA,EAAE,CAAC4E,MAAH,CAAUiB,SAAV,CAAoBU,YAApB,GAAmC,YAAW;AAE5C,QAAIE,cAAc,GAAG,UAASvE,IAAT,EAAcgB,EAAd,EAAiBmC,KAAjB,EAAwB;AAC3C,UAAIrC,OAAO,GAAI,KAAGqC,KAAlB;;AACA,UAAInC,EAAE,CAAC,CAAD,CAAF,IAAO,CAAP,IAAYA,EAAE,CAAC,CAAD,CAAF,IAAO,CAAnB,IAAwBA,EAAE,CAAC,CAAD,CAAF,GAAMF,OAA9B,IAAyCE,EAAE,CAAC,CAAD,CAAF,GAAMF,OAAnD,EAA4D;AAC1D;AACA,eAAOhD,EAAE,CAAC4E,MAAH,CAAUa,UAAV,CAAqBvD,IAArB,EAA0BgB,EAA1B,EAA6BmC,KAA7B,CAAP;AACD,OAHD,MAGO;AACL;AACA;AACA;AAEA,YAAI3C,EAAE,GAAG1C,EAAE,CAACoD,MAAH,CAAUF,EAAV,EAAamC,KAAb,EAAmB,CAAC,GAAD,EAAK,GAAL,CAAnB,CAAT;AACA,YAAI9C,EAAE,GAAGvC,EAAE,CAAC2C,MAAH,CAAUD,EAAV,CAAT;AACA,YAAIhB,GAAG,GAAG1B,EAAE,CAACwC,WAAH,CAAeN,IAAf,EAAoBK,EAApB,CAAV;AACA,YAAIoD,MAAM,GAAG3F,EAAE,CAACsC,WAAH,CAAeZ,GAAf,CAAb;AACAQ,QAAAA,IAAI,GAAGyD,MAAM,CAAC,CAAD,CAAb;AACApD,QAAAA,EAAE,GAAGoD,MAAM,CAAC,CAAD,CAAX;AACAjD,QAAAA,EAAE,GAAG1C,EAAE,CAAC6C,MAAH,CAAUN,EAAV,CAAL;AACAW,QAAAA,EAAE,GAAGlD,EAAE,CAAC8C,MAAH,CAAUJ,EAAV,EAAa2C,KAAb,CAAL;AACA,eAAOrF,EAAE,CAAC4E,MAAH,CAAUa,UAAV,CAAsBvD,IAAtB,EAA4BgB,EAA5B,EAAgCmC,KAAhC,CAAP;AACD;AACF,KApBD;;AAsBA,QAAInD,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIoC,CAAC,GAAG,KAAKpB,EAAL,CAAQ,CAAR,CAAR;AACA,QAAIwD,CAAC,GAAG,KAAKxD,EAAL,CAAQ,CAAR,CAAR;AACA,QAAImC,KAAK,GAAG,KAAKA,KAAjB;AAGA,WAAO,CACLoB,cAAc,CAACvE,IAAD,EAAO,CAACoC,CAAC,GAAC,CAAH,EAAKoC,CAAL,CAAP,EAAgBrB,KAAhB,CADT,EAELoB,cAAc,CAACvE,IAAD,EAAO,CAACoC,CAAD,EAAGoC,CAAC,GAAC,CAAL,CAAP,EAAgBrB,KAAhB,CAFT,EAGLoB,cAAc,CAACvE,IAAD,EAAO,CAACoC,CAAC,GAAC,CAAH,EAAKoC,CAAL,CAAP,EAAgBrB,KAAhB,CAHT,EAILoB,cAAc,CAACvE,IAAD,EAAO,CAACoC,CAAD,EAAGoC,CAAC,GAAC,CAAL,CAAP,EAAgBrB,KAAhB,CAJT,CAAP;AAOD,GArCD,CAxXoB,CA+ZpB;AACA;AACA;;;AACArF,EAAAA,EAAE,CAAC2G,SAAH,GAAe,CAAf;AACA3G,EAAAA,EAAE,CAAC4G,SAAH,GAAe,EAAf;AACA5G,EAAAA,EAAE,CAAC6G,QAAH,GAAe,IAAI7G,EAAE,CAAC4G,SAAR,GAAqB,CAAnC,CApaoB,CAoakB;;AAEtC5G,EAAAA,EAAE,CAAC8G,gBAAH,GAAsB9G,EAAE,CAAC4E,MAAH,CAAUkC,gBAAV,GAA6B9G,EAAE,CAAC+G,gBAAH,GAAsB,UAAUC,KAAV,EAAiBC,IAAjB,EAAuBC,MAAvB,EAA+B;AACtG,QAAIC,IAAI,GAAGpH,OAAO,CAACqH,OAAR,IAAmBrH,OAAO,CAACqH,OAAR,CAAgBD,IAAnC,IAA2CE,OAAO,CAAC,MAAD,CAA7D;;AACA,QAAIC,KAAJ;AACA,QAAIC,IAAJ;AACA,QAAIC,GAAJ;;AAEA,QAAI,CAACN,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAGD,IAAI,CAAC7B,MAAd;AACD;;AACD,QAAI6B,IAAI,CAAC7B,MAAL,GAAc8B,MAAlB,EAA0B;AACxBD,MAAAA,IAAI,GAAGA,IAAI,CAACQ,MAAL,CAAY,CAAZ,EAAeP,MAAf,CAAP;AACD,KAXqG,CAatG;;;AACAI,IAAAA,KAAK,GAAGH,IAAI,CAACO,UAAL,CAAgBV,KAAK,CAAClB,QAAN,CAAe,EAAf,CAAhB,EAAoC,IAApC,EAA0C,EAA1C,EAA8CA,QAA9C,CAAuD,CAAvD,CAAR;;AACA,WAAOwB,KAAK,CAAClC,MAAN,GAAepF,EAAE,CAAC2G,SAAzB,EAAoC;AAClCW,MAAAA,KAAK,GAAG,MAAMA,KAAd;AACD,KAjBqG,CAmBtG;;;AACAC,IAAAA,IAAI,GAAGJ,IAAI,CAACO,UAAL,CAAgBT,IAAhB,EAAsB,IAAtB,EAA4B,CAA5B,EAA+BnB,QAA/B,CAAwC,CAAxC,CAAP;;AACA,WAAOyB,IAAI,CAACnC,MAAL,GAAe,IAAI8B,MAA1B,EAAmC;AACjCK,MAAAA,IAAI,GAAG,MAAMA,IAAb;AACD;;AAEDC,IAAAA,GAAG,GAAGF,KAAK,GAAGC,IAAd,CAzBsG,CA0BtG;;AACAC,IAAAA,GAAG,IAAI,GAAP,CA3BsG,CA4BtG;;AACA,WAAOA,GAAG,CAACpC,MAAJ,GAAcpF,EAAE,CAAC2G,SAAH,GAAe3G,EAAE,CAAC6G,QAAvC,EAAkD;AAChDW,MAAAA,GAAG,IAAI,GAAP;AACD;;AAED,WAAOL,IAAI,CAACO,UAAL,CAAgBF,GAAhB,EAAqB,IAArB,EAA2B,CAA3B,EAA8B1B,QAA9B,CAAuC,EAAvC,CAAP;AACD,GAlCD;;AAoCA9F,EAAAA,EAAE,CAAC2H,OAAH,GAAa3H,EAAE,CAAC4E,MAAH,CAAU+C,OAAV,GACX3H,EAAE,CAAC4H,IAAH,GAAU5H,EAAE,CAAC6H,QAAH,GAAc7H,EAAE,CAAC8H,OAAH,GACxB,UAAUC,GAAV,EAAe;AACf,QAAIhD,KAAK,GAAGgD,GAAG,CAAC/C,KAAJ,CAAU,GAAV,CAAZ;AAEA,WAAOhF,EAAE,CAAC+G,gBAAH,CAAoBhC,KAAK,CAAC,CAAD,CAAzB,EAA8BA,KAAK,CAAC,CAAD,CAAnC,EAAwCA,KAAK,CAAC,CAAD,CAAL,CAASK,MAAjD,CAAP;AACD,GAND;;AAQApF,EAAAA,EAAE,CAACgI,OAAH,GAAahI,EAAE,CAAC4E,MAAH,CAAUoD,OAAV,GACXhI,EAAE,CAAC4E,MAAH,CAAUqD,KAAV,GAAkBjI,EAAE,CAACiI,KAAH,GAClBjI,EAAE,CAACkI,MAAH,GAAYlI,EAAE,CAACmI,UAAH,GACZnI,EAAE,CAAC4E,MAAH,CAAUwB,gBAAV,GAA8BpG,EAAE,CAACoG,gBAAH,GAC9B,UAAUgC,GAAV,EAAe;AACf,QAAIjB,IAAI,GAAGpH,OAAO,CAACqH,OAAR,IAAmBrH,OAAO,CAACqH,OAAR,CAAgBD,IAAnC,IAA2CE,OAAO,CAAC,MAAD,CAA7D;;AACA,QAAIG,GAAG,GAAGL,IAAI,CAACO,UAAL,CAAgBU,GAAhB,EAAqB,IAArB,EAA2B,EAA3B,EAA+BtC,QAA/B,CAAwC,CAAxC,CAAV;;AAEA,WAAO0B,GAAG,CAACpC,MAAJ,GAAcpF,EAAE,CAAC2G,SAAH,GAAe3G,EAAE,CAAC6G,QAAvC,EAAkD;AAChDW,MAAAA,GAAG,GAAG,MAAMA,GAAZ;AACD,KANc,CAQf;;;AACA,QAAIa,QAAQ,GAAGb,GAAG,CAACc,WAAJ,CAAgB,GAAhB,CAAf,CATe,CAUf;AACA;;AACA,QAAIhB,KAAK,GAAGE,GAAG,CAACe,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAZ,CAZe,CAaf;;AACA,QAAIhB,IAAI,GAAGC,GAAG,CAACe,SAAJ,CAAc,CAAd,EAAiBF,QAAjB,CAAX;AACA,QAAInB,MAAM,GAAGK,IAAI,CAACnC,MAAL,GAAc,CAA3B;AAEA,QAAIoD,KAAK,GAAGrB,IAAI,CAACO,UAAL,CAAgBJ,KAAhB,EAAuB,IAAvB,EAA6B,CAA7B,EAAgCxB,QAAhC,CAAyC,EAAzC,CAAZ;AACA,QAAImB,IAAI,GAAGE,IAAI,CAACO,UAAL,CAAgBH,IAAhB,EAAsB,IAAtB,EAA4B,CAA5B,EAA+BzB,QAA/B,CAAwC,CAAxC,CAAX;;AAEA,WAAOmB,IAAI,CAAC7B,MAAL,GAAc8B,MAArB,EAA6B;AAC3BD,MAAAA,IAAI,GAAG,MAAMA,IAAb;AACD;;AAED,WAAOuB,KAAK,GAAG,GAAR,GAAcvB,IAArB;AACD,GA7BD;;AA+BAjH,EAAAA,EAAE,CAACyI,WAAH,GAAiBzI,EAAE,CAAC4E,MAAH,CAAU6D,WAAV,GAAwB,UAAUV,GAAV,EAAe;AACtD,QAAIW,KAAK,GAAG1I,EAAE,CAAC4E,MAAH,CAAUC,kBAAV,CAA6BkD,GAA7B,CAAZ;AACA,WAAOW,KAAK,CAAC3C,SAAN,EAAP;AACD,GAHD;;AAKA/F,EAAAA,EAAE,CAAC2I,UAAH,GAAgB3I,EAAE,CAAC4E,MAAH,CAAU+D,UAAV,GAAuB,UAAUC,EAAV,EAAc;AACnD,QAAIb,GAAG,GAAG/H,EAAE,CAACgI,OAAH,CAAWY,EAAX,CAAV;AACA,WAAO5I,EAAE,CAACyI,WAAH,CAAeV,GAAf,CAAP;AACD,GAHD;;AAKA/H,EAAAA,EAAE,CAAC4E,MAAH,CAAUiE,WAAV,GAAwB7I,EAAE,CAAC6I,WAAH,GACtB7I,EAAE,CAAC8I,eAAH,GAAqB,UAAUxI,GAAV,EAAeE,GAAf,EAAoB6E,KAApB,EAA2B;AAChD,QAAI5E,KAAK,CAAC4E,KAAD,CAAL,IAAgBA,KAAK,GAAG,CAAxB,IAA6BA,KAAK,GAAG,EAAzC,EAA6C;AAC3C,YAAM,IAAI3E,KAAJ,CAAU,6DAAV,CAAN;AACD,KAH+C,CAIhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAOV,EAAE,CAAC4E,MAAH,CAAUc,UAAV,CAAqB;AAAEpF,MAAAA,GAAG,EAAEA,GAAP;AAAYE,MAAAA,GAAG,EAAEA;AAAjB,KAArB,EAA6C6E,KAA7C,EAAoDe,gBAApD,EAAP;AACD,GArBD;;AAuBApG,EAAAA,EAAE,CAAC+I,OAAH,GAAa,UAAUhB,GAAV,EAAeiB,GAAf,EAAoB;AAC/B,QAAI7B,IAAI,GAAGpH,OAAO,CAACqH,OAAR,IAAmBrH,OAAO,CAACqH,OAAR,CAAgBD,IAAnC,IAA2CE,OAAO,CAAC,MAAD,CAA7D;;AACA,QAAItC,KAAK,GAAGgD,GAAG,CAAC/C,KAAJ,CAAU,GAAV,CAAZ;AAEA,QAAIwD,KAAK,GAAGzD,KAAK,CAAC,CAAD,CAAjB;AACA,QAAIkC,IAAI,GAAGlC,KAAK,CAAC,CAAD,CAAhB;AACA,QAAIM,KAAK,GAAGN,KAAK,CAAC,CAAD,CAAL,CAASK,MAArB;AAEA,QAAI6D,IAAI,GAAG9B,IAAI,CAACO,UAAL,CAAgBT,IAAhB,EAAsB,IAAtB,EAA4B,CAA5B,CAAX,CAR+B,CAS/B;AACA;;AACA,QAAIiC,MAAJ;;AACA,QAAIF,GAAG,GAAG,CAAV,EAAa;AACXE,MAAAA,MAAM,GAAGD,IAAI,CAACE,GAAL,CAASxI,IAAI,CAACqB,GAAL,CAASgH,GAAT,CAAT,CAAT;AACD,KAFD,MAGK,IAAIA,GAAG,GAAG,CAAV,EAAa;AAChBE,MAAAA,MAAM,GAAGD,IAAI,CAACG,QAAL,CAAczI,IAAI,CAACqB,GAAL,CAASgH,GAAT,CAAd,CAAT;AACD;;AACD,QAAIK,MAAM,GAAGH,MAAM,CAACpD,QAAP,CAAgB,CAAhB,CAAb;;AAEA,QAAI,QAAQuD,MAAZ,EAAoB;AAClBpF,MAAAA,OAAO,CAACqF,OAAR,CAAgB,IAAI5I,KAAJ,CAAU,6CAAV,CAAhB;AACD;;AAED,WAAO2I,MAAM,CAACjE,MAAP,GAAgBC,KAAvB,EAA8B;AAC5BgE,MAAAA,MAAM,GAAG,MAAMA,MAAf;AACD;;AAED,WAAOb,KAAK,GAAG,GAAR,GAAca,MAArB;AACD,GA7BD;;AA+BArJ,EAAAA,EAAE,CAAC4E,MAAH,CAAU2E,OAAV,GAAoBvJ,EAAE,CAACuJ,OAAH,GAAa,UAAUxB,GAAV,EAAe;AAC9C,WAAO/H,EAAE,CAAC+I,OAAH,CAAWhB,GAAX,EAAgB,CAAC,CAAjB,CAAP;AACD,GAFD;;AAIA/H,EAAAA,EAAE,CAAC4E,MAAH,CAAU4E,OAAV,GAAoBxJ,EAAE,CAACwJ,OAAH,GAAa,UAAUzB,GAAV,EAAe;AAC9C,WAAO/H,EAAE,CAAC+I,OAAH,CAAWhB,GAAX,EAAgB,CAAhB,CAAP;AACD,GAFD;AAIC,CAzjBD,EAyjBG,gBAAgB,OAAO0B,MAAvB,GAAgCA,MAAM,CAAC1J,OAAvC,GAAiD2J,MAzjBpD","sourcesContent":["/// S2 Geometry functions\n// the regional scoreboard is based on a level 6 S2 Cell\n// - https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i22\n// at the time of writing there's no actual API for the intel map to retrieve scoreboard data,\n// but it's still useful to plot the score cells on the intel map\n\n\n// the S2 geometry is based on projecting the earth sphere onto a cube, with some scaling of face coordinates to\n// keep things close to approximate equal area for adjacent cells\n// to convert a lat,lng into a cell id:\n// - convert lat,lng to x,y,z\n// - convert x,y,z into face,u,v\n// - u,v scaled to s,t with quadratic formula\n// - s,t converted to integer i,j offsets\n// - i,j converted to a position along a Hubbert space-filling curve\n// - combine face,position to get the cell id\n\n//NOTE: compared to the google S2 geometry library, we vary from their code in the following ways\n// - cell IDs: they combine face and the hilbert curve position into a single 64 bit number. this gives efficient space\n//             and speed. javascript doesn't have appropriate data types, and speed is not cricical, so we use\n//             as [face,[bitpair,bitpair,...]] instead\n// - i,j: they always use 30 bits, adjusting as needed. we use 0 to (1<<level)-1 instead\n//        (so GetSizeIJ for a cell is always 1)\n\n(function (exports) {\n'use strict';\n\nvar S2 = exports.S2 = { L: {} };\n\nS2.L.LatLng = function (/*Number*/ rawLat, /*Number*/ rawLng, /*Boolean*/ noWrap) {\n  var lat = parseFloat(rawLat, 10);\n  var lng = parseFloat(rawLng, 10);\n\n  if (isNaN(lat) || isNaN(lng)) {\n    throw new Error('Invalid LatLng object: (' + rawLat + ', ' + rawLng + ')');\n  }\n\n  if (noWrap !== true) {\n    lat = Math.max(Math.min(lat, 90), -90);                 // clamp latitude into -90..90\n    lng = (lng + 180) % 360 + ((lng < -180 || lng === 180) ? 180 : -180);   // wrap longtitude into -180..180\n  }\n\n  return { lat: lat, lng: lng };\n};\n\nS2.L.LatLng.DEG_TO_RAD = Math.PI / 180;\nS2.L.LatLng.RAD_TO_DEG = 180 / Math.PI;\n\n/*\nS2.LatLngToXYZ = function(latLng) {\n  // http://stackoverflow.com/questions/8981943/lat-long-to-x-y-z-position-in-js-not-working\n  var lat = latLng.lat;\n  var lon = latLng.lng;\n  var DEG_TO_RAD = Math.PI / 180.0;\n\n  var phi = lat * DEG_TO_RAD;\n  var theta = lon * DEG_TO_RAD;\n\n  var cosLat = Math.cos(phi);\n  var sinLat = Math.sin(phi);\n  var cosLon = Math.cos(theta);\n  var sinLon = Math.sin(theta);\n  var rad = 500.0;\n\n  return [\n    rad * cosLat * cosLon\n  , rad * cosLat * sinLon\n  , rad * sinLat\n  ];\n};\n*/\nS2.LatLngToXYZ = function(latLng) {\n  var d2r = S2.L.LatLng.DEG_TO_RAD;\n\n  var phi = latLng.lat*d2r;\n  var theta = latLng.lng*d2r;\n\n  var cosphi = Math.cos(phi);\n\n  return [Math.cos(theta)*cosphi, Math.sin(theta)*cosphi, Math.sin(phi)];\n};\n\nS2.XYZToLatLng = function(xyz) {\n  var r2d = S2.L.LatLng.RAD_TO_DEG;\n\n  var lat = Math.atan2(xyz[2], Math.sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]));\n  var lng = Math.atan2(xyz[1], xyz[0]);\n\n  return S2.L.LatLng(lat*r2d, lng*r2d);\n};\n\nvar largestAbsComponent = function(xyz) {\n  var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];\n\n  if (temp[0] > temp[1]) {\n    if (temp[0] > temp[2]) {\n      return 0;\n    } else {\n      return 2;\n    }\n  } else {\n    if (temp[1] > temp[2]) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n};\n\nvar faceXYZToUV = function(face,xyz) {\n  var u,v;\n\n  switch (face) {\n    case 0: u =  xyz[1]/xyz[0]; v =  xyz[2]/xyz[0]; break;\n    case 1: u = -xyz[0]/xyz[1]; v =  xyz[2]/xyz[1]; break;\n    case 2: u = -xyz[0]/xyz[2]; v = -xyz[1]/xyz[2]; break;\n    case 3: u =  xyz[2]/xyz[0]; v =  xyz[1]/xyz[0]; break;\n    case 4: u =  xyz[2]/xyz[1]; v = -xyz[0]/xyz[1]; break;\n    case 5: u = -xyz[1]/xyz[2]; v = -xyz[0]/xyz[2]; break;\n    default: throw {error: 'Invalid face'};\n  }\n\n  return [u,v];\n};\n\n\n\n\nS2.XYZToFaceUV = function(xyz) {\n  var face = largestAbsComponent(xyz);\n\n  if (xyz[face] < 0) {\n    face += 3;\n  }\n\n  var uv = faceXYZToUV (face,xyz);\n\n  return [face, uv];\n};\n\nS2.FaceUVToXYZ = function(face,uv) {\n  var u = uv[0];\n  var v = uv[1];\n\n  switch (face) {\n    case 0: return [ 1, u, v];\n    case 1: return [-u, 1, v];\n    case 2: return [-u,-v, 1];\n    case 3: return [-1,-v,-u];\n    case 4: return [ v,-1,-u];\n    case 5: return [ v, u,-1];\n    default: throw {error: 'Invalid face'};\n  }\n};\n\nvar singleSTtoUV = function(st) {\n  if (st >= 0.5) {\n    return (1/3.0) * (4*st*st - 1);\n  } else {\n    return (1/3.0) * (1 - (4*(1-st)*(1-st)));\n  }\n};\n\nS2.STToUV = function(st) {\n  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n};\n\n\nvar singleUVtoST = function(uv) {\n  if (uv >= 0) {\n    return 0.5 * Math.sqrt (1 + 3*uv);\n  } else {\n    return 1 - 0.5 * Math.sqrt (1 - 3*uv);\n  }\n};\nS2.UVToST = function(uv) {\n  return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];\n};\n\n\nS2.STToIJ = function(st,order) {\n  var maxSize = (1<<order);\n\n  var singleSTtoIJ = function(st) {\n    var ij = Math.floor(st * maxSize);\n    return Math.max(0, Math.min(maxSize-1, ij));\n  };\n\n  return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];\n};\n\n\nS2.IJToST = function(ij,order,offsets) {\n  var maxSize = (1<<order);\n\n  return [\n    (ij[0]+offsets[0])/maxSize,\n    (ij[1]+offsets[1])/maxSize\n  ];\n};\n\n\n\nvar rotateAndFlipQuadrant = function(n, point, rx, ry)\n{\n\tvar newX, newY;\n\tif(ry == 0)\n\t{\n\t\tif(rx == 1){\n\t\t\tpoint.x = n - 1 - point.x;\n\t\t\tpoint.y = n - 1 - point.y\n\n\t\t}\n\n    var x = point.x;\n\t\tpoint.x = point.y\n\t\tpoint.y = x;\n\t}\n\n}\n\n\n\n\n\n// hilbert space-filling curve\n// based on http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves\n// note: rather then calculating the final integer hilbert position, we just return the list of quads\n// this ensures no precision issues whth large orders (S3 cell IDs use up to 30), and is more\n// convenient for pulling out the individual bits as needed later\nvar pointToHilbertQuadList = function(x,y,order,face) {\n  var hilbertMap = {\n    'a': [ [0,'d'], [1,'a'], [3,'b'], [2,'a'] ],\n    'b': [ [2,'b'], [1,'b'], [3,'a'], [0,'c'] ],\n    'c': [ [2,'c'], [3,'d'], [1,'c'], [0,'b'] ],\n    'd': [ [0,'a'], [3,'c'], [1,'d'], [2,'d'] ]\n  };\n\n  if ('number' !== typeof face) {\n    console.warn(new Error(\"called pointToHilbertQuadList without face value, defaulting to '0'\").stack);\n  }\n  var currentSquare = (face % 2) ? 'd' : 'a';\n  var positions = [];\n\n  for (var i=order-1; i>=0; i--) {\n\n    var mask = 1<<i;\n\n    var quad_x = x&mask ? 1 : 0;\n    var quad_y = y&mask ? 1 : 0;\n\n    var t = hilbertMap[currentSquare][quad_x*2+quad_y];\n\n    positions.push(t[0]);\n\n    currentSquare = t[1];\n  }\n\n  return positions;\n};\n\n// S2Cell class\n\nS2.S2Cell = function(){};\n\nS2.S2Cell.FromHilbertQuadKey = function(hilbertQuadkey) {\n  var parts = hilbertQuadkey.split('/');\n  var face = parseInt(parts[0]);\n  var position = parts[1];\n  var maxLevel = position.length;\n  var point = {\n    x : 0,\n    y: 0\n  };\n  var i;\n  var level;\n  var bit;\n  var rx, ry;\n  var val;\n\n\tfor(i = maxLevel - 1; i >= 0; i--) {\n\n\t\tlevel = maxLevel - i;\n\t\tbit = position[i];\n\t\trx = 0;\n    ry = 0;\n\t\tif (bit === '1') {\n\t\t\try = 1;\n\t\t}\n\t\telse if (bit === '2') {\n\t\t\trx = 1;\n\t\t\try = 1;\n\t\t}\n\t\telse if (bit === '3') {\n\t\t\trx = 1;\n\t\t}\n\n\t\tval = Math.pow(2, level - 1);\n\t\trotateAndFlipQuadrant(val, point, rx, ry);\n\n\t\tpoint.x += val * rx;\n\t\tpoint.y += val * ry;\n\n\t}\n\n  if (face % 2 === 1) {\n    var t = point.x;\n    point.x = point.y;\n    point.y = t;\n  }\n\n\n  return S2.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);\n};\n\n//static method to construct\nS2.S2Cell.FromLatLng = function(latLng, level) {\n  if ((!latLng.lat && latLng.lat !== 0) || (!latLng.lng && latLng.lng !== 0)) {\n    throw new Error(\"Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng\");\n  }\n  var xyz = S2.LatLngToXYZ(latLng);\n\n  var faceuv = S2.XYZToFaceUV(xyz);\n  var st = S2.UVToST(faceuv[1]);\n\n  var ij = S2.STToIJ(st,level);\n\n  return S2.S2Cell.FromFaceIJ (faceuv[0], ij, level);\n};\n\n/*\nS2.faceIjLevelToXyz = function (face, ij, level) {\n  var st = S2.IJToST(ij, level, [0.5, 0.5]);\n  var uv = S2.STToUV(st);\n  var xyz = S2.FaceUVToXYZ(face, uv);\n\n  return S2.XYZToLatLng(xyz);\n  return xyz;\n};\n*/\n\nS2.S2Cell.FromFaceIJ = function(face,ij,level) {\n  var cell = new S2.S2Cell();\n  cell.face = face;\n  cell.ij = ij;\n  cell.level = level;\n\n  return cell;\n};\n\n\nS2.S2Cell.prototype.toString = function() {\n  return 'F'+this.face+'ij['+this.ij[0]+','+this.ij[1]+']@'+this.level;\n};\n\nS2.S2Cell.prototype.getLatLng = function() {\n  var st = S2.IJToST(this.ij,this.level, [0.5,0.5]);\n  var uv = S2.STToUV(st);\n  var xyz = S2.FaceUVToXYZ(this.face, uv);\n\n  return S2.XYZToLatLng(xyz);\n};\n\nS2.S2Cell.prototype.getCornerLatLngs = function() {\n  var result = [];\n  var offsets = [\n    [ 0.0, 0.0 ],\n    [ 0.0, 1.0 ],\n    [ 1.0, 1.0 ],\n    [ 1.0, 0.0 ]\n  ];\n\n  for (var i=0; i<4; i++) {\n    var st = S2.IJToST(this.ij, this.level, offsets[i]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(this.face, uv);\n\n    result.push ( S2.XYZToLatLng(xyz) );\n  }\n  return result;\n};\n\n\nS2.S2Cell.prototype.getFaceAndQuads = function () {\n  var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n\n  return [this.face,quads];\n};\nS2.S2Cell.prototype.toHilbertQuadkey = function () {\n  var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n\n  return this.face.toString(10) + '/' + quads.join('');\n};\n\nS2.latLngToNeighborKeys = S2.S2Cell.latLngToNeighborKeys = function (lat, lng, level) {\n  return S2.S2Cell.FromLatLng({ lat: lat, lng: lng }, level).getNeighbors().map(function (cell) {\n    return cell.toHilbertQuadkey();\n  });\n};\nS2.S2Cell.prototype.getNeighbors = function() {\n\n  var fromFaceIJWrap = function(face,ij,level) {\n    var maxSize = (1<<level);\n    if (ij[0]>=0 && ij[1]>=0 && ij[0]<maxSize && ij[1]<maxSize) {\n      // no wrapping out of bounds\n      return S2.S2Cell.FromFaceIJ(face,ij,level);\n    } else {\n      // the new i,j are out of range.\n      // with the assumption that they're only a little past the borders we can just take the points as\n      // just beyond the cube face, project to XYZ, then re-create FaceUV from the XYZ vector\n\n      var st = S2.IJToST(ij,level,[0.5,0.5]);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(face,uv);\n      var faceuv = S2.XYZToFaceUV(xyz);\n      face = faceuv[0];\n      uv = faceuv[1];\n      st = S2.UVToST(uv);\n      ij = S2.STToIJ(st,level);\n      return S2.S2Cell.FromFaceIJ (face, ij, level);\n    }\n  };\n\n  var face = this.face;\n  var i = this.ij[0];\n  var j = this.ij[1];\n  var level = this.level;\n\n\n  return [\n    fromFaceIJWrap(face, [i-1,j], level),\n    fromFaceIJWrap(face, [i,j-1], level),\n    fromFaceIJWrap(face, [i+1,j], level),\n    fromFaceIJWrap(face, [i,j+1], level)\n  ];\n\n};\n\n//\n// Functional Style\n//\nS2.FACE_BITS = 3;\nS2.MAX_LEVEL = 30;\nS2.POS_BITS = (2 * S2.MAX_LEVEL) + 1; // 61 (60 bits of data, 1 bit lsb marker)\n\nS2.facePosLevelToId = S2.S2Cell.facePosLevelToId = S2.fromFacePosLevel = function (faceN, posS, levelN) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var faceB;\n  var posB;\n  var bin;\n\n  if (!levelN) {\n    levelN = posS.length;\n  }\n  if (posS.length > levelN) {\n    posS = posS.substr(0, levelN);\n  }\n\n  // 3-bit face value\n  faceB = Long.fromString(faceN.toString(10), true, 10).toString(2);\n  while (faceB.length < S2.FACE_BITS) {\n    faceB = '0' + faceB;\n  }\n\n  // 60-bit position value\n  posB = Long.fromString(posS, true, 4).toString(2);\n  while (posB.length < (2 * levelN)) {\n    posB = '0' + posB;\n  }\n\n  bin = faceB + posB;\n  // 1-bit lsb marker\n  bin += '1';\n  // n-bit padding to 64-bits\n  while (bin.length < (S2.FACE_BITS + S2.POS_BITS)) {\n    bin += '0';\n  }\n\n  return Long.fromString(bin, true, 2).toString(10);\n};\n\nS2.keyToId = S2.S2Cell.keyToId\n= S2.toId = S2.toCellId = S2.fromKey\n= function (key) {\n  var parts = key.split('/');\n\n  return S2.fromFacePosLevel(parts[0], parts[1], parts[1].length);\n};\n\nS2.idToKey = S2.S2Cell.idToKey\n= S2.S2Cell.toKey = S2.toKey\n= S2.fromId = S2.fromCellId\n= S2.S2Cell.toHilbertQuadkey  = S2.toHilbertQuadkey\n= function (idS) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var bin = Long.fromString(idS, true, 10).toString(2);\n\n  while (bin.length < (S2.FACE_BITS + S2.POS_BITS)) {\n    bin = '0' + bin;\n  }\n\n  // MUST come AFTER binstr has been left-padded with '0's\n  var lsbIndex = bin.lastIndexOf('1');\n  // substr(start, len)\n  // substring(start, end) // includes start, does not include end\n  var faceB = bin.substring(0, 3);\n  // posB will always be a multiple of 2 (or it's invalid)\n  var posB = bin.substring(3, lsbIndex);\n  var levelN = posB.length / 2;\n\n  var faceS = Long.fromString(faceB, true, 2).toString(10);\n  var posS = Long.fromString(posB, true, 2).toString(4);\n\n  while (posS.length < levelN) {\n    posS = '0' + posS;\n  }\n\n  return faceS + '/' + posS;\n};\n\nS2.keyToLatLng = S2.S2Cell.keyToLatLng = function (key) {\n  var cell2 = S2.S2Cell.FromHilbertQuadKey(key);\n  return cell2.getLatLng();\n};\n\nS2.idToLatLng = S2.S2Cell.idToLatLng = function (id) {\n  var key = S2.idToKey(id);\n  return S2.keyToLatLng(key);\n};\n\nS2.S2Cell.latLngToKey = S2.latLngToKey\n= S2.latLngToQuadkey = function (lat, lng, level) {\n  if (isNaN(level) || level < 1 || level > 30) {\n    throw new Error(\"'level' is not a number between 1 and 30 (but it should be)\");\n  }\n  // TODO\n  //\n  // S2.idToLatLng(id)\n  // S2.keyToLatLng(key)\n  // S2.nextFace(key)     // prevent wrapping on nextKey\n  // S2.prevFace(key)     // prevent wrapping on prevKey\n  //\n  // .toKeyArray(id)  // face,quadtree\n  // .toKey(id)       // hilbert\n  // .toPoint(id)     // ij\n  // .toId(key)       // uint64 (as string)\n  // .toLong(key)     // long.js\n  // .toLatLng(id)    // object? or array?, or string (with comma)?\n  //\n  // maybe S2.HQ.x, S2.GPS.x, S2.CI.x?\n  return S2.S2Cell.FromLatLng({ lat: lat, lng: lng }, level).toHilbertQuadkey();\n};\n\nS2.stepKey = function (key, num) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var parts = key.split('/');\n\n  var faceS = parts[0];\n  var posS = parts[1];\n  var level = parts[1].length;\n\n  var posL = Long.fromString(posS, true, 4);\n  // TODO handle wrapping (0 === pos + 1)\n  // (only on the 12 edges of the globe)\n  var otherL;\n  if (num > 0) {\n    otherL = posL.add(Math.abs(num));\n  }\n  else if (num < 0) {\n    otherL = posL.subtract(Math.abs(num));\n  }\n  var otherS = otherL.toString(4);\n\n  if ('0' === otherS) {\n    console.warning(new Error(\"face/position wrapping is not yet supported\"));\n  }\n\n  while (otherS.length < level) {\n    otherS = '0' + otherS;\n  }\n\n  return faceS + '/' + otherS;\n};\n\nS2.S2Cell.prevKey = S2.prevKey = function (key) {\n  return S2.stepKey(key, -1);\n};\n\nS2.S2Cell.nextKey = S2.nextKey = function (key) {\n  return S2.stepKey(key, 1);\n};\n\n})('undefined' !== typeof module ? module.exports : window);\n"]},"metadata":{},"sourceType":"script"}