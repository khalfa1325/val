{"ast":null,"code":"// (c) 2018, Mariusz Nowak\n// SPDX-License-Identifier: ISC\n// Derived from https://github.com/medikoo/lru-queue\nexport function lruQueue(limit) {\n  var size = 0;\n  var base = 1;\n  var queue = Object.create(null);\n  var map = Object.create(null);\n  var index = 0;\n\n  var del = function del(id) {\n    var oldIndex = map[id];\n    if (!oldIndex) return;\n    delete queue[oldIndex];\n    delete map[id];\n    --size;\n    if (base !== oldIndex) return;\n\n    if (!size) {\n      index = 0;\n      base = 1;\n      return;\n    }\n\n    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {\n      /* empty */\n    }\n  };\n\n  limit = Math.abs(limit);\n  return {\n    hit: function hit(id) {\n      var oldIndex = map[id];\n      var nuIndex = ++index;\n      queue[nuIndex] = id;\n      map[id] = nuIndex;\n\n      if (!oldIndex) {\n        ++size;\n        if (size <= limit) return undefined;\n        id = queue[base];\n        del(id);\n        return id;\n      }\n\n      delete queue[oldIndex];\n      if (base !== oldIndex) return undefined;\n\n      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {\n        /* empty */\n      }\n\n      return undefined;\n    },\n    delete: del,\n    clear: function clear() {\n      size = index = 0;\n      base = 1;\n      queue = Object.create(null);\n      map = Object.create(null);\n    }\n  };\n}","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/utils/lruQueue.js"],"names":["lruQueue","limit","size","base","queue","Object","create","map","index","del","id","oldIndex","prototype","hasOwnProperty","call","Math","abs","hit","nuIndex","undefined","delete","clear"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyB;AAC9B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;AACA,MAAIC,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAV;AACA,MAAIE,KAAK,GAAG,CAAZ;;AACA,MAAIC,GAAG,GAAG,SAASA,GAAT,CAAaC,EAAb,EAAiB;AACzB,QAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,QAAI,CAACC,QAAL,EAAe;AACf,WAAOP,KAAK,CAACO,QAAD,CAAZ;AACA,WAAOJ,GAAG,CAACG,EAAD,CAAV;AACA,MAAER,IAAF;AACA,QAAIC,IAAI,KAAKQ,QAAb,EAAuB;;AACvB,QAAI,CAACT,IAAL,EAAW;AACTM,MAAAA,KAAK,GAAG,CAAR;AACAL,MAAAA,IAAI,GAAG,CAAP;AACA;AACD;;AACD,WAAO,CAACE,MAAM,CAACO,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,KAArC,EAA4C,EAAED,IAA9C,CAAR,EAA6D;AAAC;AAAY;AAC3E,GAbD;;AAcAF,EAAAA,KAAK,GAAGc,IAAI,CAACC,GAAL,CAASf,KAAT,CAAR;AACA,SAAO;AACLgB,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaP,EAAb,EAAiB;AACpB,UAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,UAAIQ,OAAO,GAAG,EAAEV,KAAhB;AACAJ,MAAAA,KAAK,CAACc,OAAD,CAAL,GAAiBR,EAAjB;AACAH,MAAAA,GAAG,CAACG,EAAD,CAAH,GAAUQ,OAAV;;AACA,UAAI,CAACP,QAAL,EAAe;AACb,UAAET,IAAF;AACA,YAAIA,IAAI,IAAID,KAAZ,EAAmB,OAAOkB,SAAP;AACnBT,QAAAA,EAAE,GAAGN,KAAK,CAACD,IAAD,CAAV;AACAM,QAAAA,GAAG,CAACC,EAAD,CAAH;AACA,eAAOA,EAAP;AACD;;AACD,aAAON,KAAK,CAACO,QAAD,CAAZ;AACA,UAAIR,IAAI,KAAKQ,QAAb,EAAuB,OAAOQ,SAAP;;AACvB,aAAO,CAACd,MAAM,CAACO,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,KAArC,EAA4C,EAAED,IAA9C,CAAR,EAA6D;AAAC;AAAY;;AAC1E,aAAOgB,SAAP;AACD,KAjBI;AAkBLC,IAAAA,MAAM,EAAEX,GAlBH;AAmBLY,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtBnB,MAAAA,IAAI,GAAGM,KAAK,GAAG,CAAf;AACAL,MAAAA,IAAI,GAAG,CAAP;AACAC,MAAAA,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAR;AACAC,MAAAA,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAN;AACD;AAxBI,GAAP;AA0BD","sourcesContent":["// (c) 2018, Mariusz Nowak\n// SPDX-License-Identifier: ISC\n// Derived from https://github.com/medikoo/lru-queue\nexport function lruQueue(limit) {\n  var size = 0;\n  var base = 1;\n  var queue = Object.create(null);\n  var map = Object.create(null);\n  var index = 0;\n  var del = function del(id) {\n    var oldIndex = map[id];\n    if (!oldIndex) return;\n    delete queue[oldIndex];\n    delete map[id];\n    --size;\n    if (base !== oldIndex) return;\n    if (!size) {\n      index = 0;\n      base = 1;\n      return;\n    }\n    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {/* empty */}\n  };\n  limit = Math.abs(limit);\n  return {\n    hit: function hit(id) {\n      var oldIndex = map[id];\n      var nuIndex = ++index;\n      queue[nuIndex] = id;\n      map[id] = nuIndex;\n      if (!oldIndex) {\n        ++size;\n        if (size <= limit) return undefined;\n        id = queue[base];\n        del(id);\n        return id;\n      }\n      delete queue[oldIndex];\n      if (base !== oldIndex) return undefined;\n      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {/* empty */}\n      return undefined;\n    },\n    delete: del,\n    clear: function clear() {\n      size = index = 0;\n      base = 1;\n      queue = Object.create(null);\n      map = Object.create(null);\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}