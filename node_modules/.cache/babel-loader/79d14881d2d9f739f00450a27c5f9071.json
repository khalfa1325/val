{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isNode } from '../../utils/is.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { escape, stringify } from '../../utils/string.js';\nvar name = 'ObjectNode';\nvar dependencies = ['Node'];\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  class ObjectNode extends Node {\n    /**\n     * @constructor ObjectNode\n     * @extends {Node}\n     * Holds an object with keys/values\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\n     */\n    constructor(properties) {\n      super();\n      this.properties = properties || {}; // validate input\n\n      if (properties) {\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\n          return isNode(properties[key]);\n        })) {\n          throw new TypeError('Object containing Nodes expected');\n        }\n      }\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isObjectNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var evalEntries = {};\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          // we stringify/parse the key here to resolve unicode characters,\n          // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n          var stringifiedKey = stringify(key);\n          var parsedKey = JSON.parse(stringifiedKey);\n          var prop = getSafeProperty(this.properties, key);\n          evalEntries[parsedKey] = prop._compile(math, argNames);\n        }\n      }\n\n      return function evalObjectNode(scope, args, context) {\n        var obj = {};\n\n        for (var _key in evalEntries) {\n          if (hasOwnProperty(evalEntries, _key)) {\n            obj[_key] = evalEntries[_key](scope, args, context);\n          }\n        }\n\n        return obj;\n      };\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n        }\n      }\n    }\n    /**\n     * Create a new ObjectNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ObjectNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var properties = {};\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n        }\n      }\n\n      return new ObjectNode(properties);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ObjectNode}\n     */\n\n\n    clone() {\n      var properties = {};\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this.properties[key];\n        }\n      }\n\n      return new ObjectNode(properties);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    _toString(options) {\n      var entries = [];\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n        }\n      }\n\n      return '{' + entries.join(', ') + '}';\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        properties: this.properties\n      };\n    }\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\n     *                       where mathjs is optional\n     * @returns {ObjectNode}\n     */\n\n\n    static fromJSON(json) {\n      return new ObjectNode(json.properties);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    toHTML(options) {\n      var entries = [];\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\n        }\n      }\n\n      return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var entries = [];\n\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n        }\n      }\n\n      var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\n      return tex;\n    }\n\n  }\n\n  _defineProperty(ObjectNode, \"name\", name);\n\n  return ObjectNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/expression/node/ObjectNode.js"],"names":["_defineProperty","getSafeProperty","factory","isNode","hasOwnProperty","escape","stringify","name","dependencies","createObjectNode","_ref","Node","ObjectNode","constructor","properties","Object","keys","every","key","TypeError","type","isObjectNode","_compile","math","argNames","evalEntries","stringifiedKey","parsedKey","JSON","parse","prop","evalObjectNode","scope","args","context","obj","_key","forEach","callback","map","_ifNode","clone","_toString","options","entries","push","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","tex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isNode } from '../../utils/is.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { escape, stringify } from '../../utils/string.js';\nvar name = 'ObjectNode';\nvar dependencies = ['Node'];\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  class ObjectNode extends Node {\n    /**\n     * @constructor ObjectNode\n     * @extends {Node}\n     * Holds an object with keys/values\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\n     */\n    constructor(properties) {\n      super();\n      this.properties = properties || {};\n\n      // validate input\n      if (properties) {\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\n          return isNode(properties[key]);\n        })) {\n          throw new TypeError('Object containing Nodes expected');\n        }\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isObjectNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalEntries = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          // we stringify/parse the key here to resolve unicode characters,\n          // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n          var stringifiedKey = stringify(key);\n          var parsedKey = JSON.parse(stringifiedKey);\n          var prop = getSafeProperty(this.properties, key);\n          evalEntries[parsedKey] = prop._compile(math, argNames);\n        }\n      }\n      return function evalObjectNode(scope, args, context) {\n        var obj = {};\n        for (var _key in evalEntries) {\n          if (hasOwnProperty(evalEntries, _key)) {\n            obj[_key] = evalEntries[_key](scope, args, context);\n          }\n        }\n        return obj;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n        }\n      }\n    }\n\n    /**\n     * Create a new ObjectNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ObjectNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var properties = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n        }\n      }\n      return new ObjectNode(properties);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ObjectNode}\n     */\n    clone() {\n      var properties = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this.properties[key];\n        }\n      }\n      return new ObjectNode(properties);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toString(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n        }\n      }\n      return '{' + entries.join(', ') + '}';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        properties: this.properties\n      };\n    }\n\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\n     *                       where mathjs is optional\n     * @returns {ObjectNode}\n     */\n    static fromJSON(json) {\n      return new ObjectNode(json.properties);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    toHTML(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\n        }\n      }\n      return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n        }\n      }\n      var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\n      return tex;\n    }\n  }\n  _defineProperty(ObjectNode, \"name\", name);\n  return ObjectNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}