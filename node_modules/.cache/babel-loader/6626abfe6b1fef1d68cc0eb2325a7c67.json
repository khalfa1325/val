{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport { isInteger } from './number.js';\nimport { isNumber, isBigNumber, isArray, isString } from './is.js';\nimport { format } from './string.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\nimport { deepStrictEqual } from './object.js';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Validate whether the source of the index matches the size of the Array\n * @param {Array | Matrix} array    Array to be validated\n * @param {Index} index  Index with the source information to validate\n * @throws DimensionError\n */\n\nexport function validateIndexSourceSize(value, index) {\n  var valueSize = value.isMatrix ? value._size : arraySize(value);\n  var sourceSize = index._sourceSize; // checks if the source size is not null and matches the valueSize\n\n  sourceSize.forEach((sourceDim, i) => {\n    if (sourceDim !== null && sourceDim !== valueSize[i]) {\n      throw new DimensionError(sourceDim, valueSize[i]);\n    }\n  });\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (index !== undefined) {\n    if (!isNumber(index) || !isInteger(index)) {\n      throw new TypeError('Index must be an integer (value: ' + index + ')');\n    }\n\n    if (index < 0 || typeof length === 'number' && index >= length) {\n      throw new IndexError(index, length);\n    }\n  }\n}\n/**\n * Test if and index has empty values\n * @param {number} index    Zero-based index\n */\n\nexport function isEmptyIndex(index) {\n  for (var i = 0; i < index._dimensions.length; ++i) {\n    var dimension = index._dimensions[i];\n\n    if (dimension._data && isArray(dimension._data)) {\n      if (dimension._size[0] === 0) {\n        return true;\n      }\n    } else if (dimension.isRange) {\n      if (dimension.start === dimension.end) {\n        return true;\n      }\n    } else if (isString(dimension)) {\n      if (dimension.length === 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array | number} array         Array to be resized\n * @param {number[]} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // check the type of the arguments\n  if (!Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // convert number to an array\n\n  if (isNumber(array) || isBigNumber(array)) {\n    array = [array];\n  } // recursively resize the array\n\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {number[]} sizes        List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, currentLength, '!=');\n  }\n\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n\n  if (currentLength !== newLength) {\n    throw new DimensionError(newLength, currentLength, '!=');\n  }\n\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(newLength, currentLength, '!=');\n    }\n\n    throw e;\n  }\n}\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {number[]} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {number[]}      The sizes array with wildcard replaced.\n */\n\nexport function processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n\n  return processedSizes;\n}\n/**\n * Computes the product of all array elements.\n * @param {number[]} array Array of factors\n * @returns {number}            Product of all elements\n */\n\nfunction product(array) {\n  return array.reduce((prev, curr) => prev * curr, 1);\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {number[]} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, entry => regexp.test(entry));\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n\n    var _isArray = Array.isArray(item); // Saving the target matrix row size\n\n\n    if (i === 0 && _isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (_isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = _isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param {array}\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n * @param {array}\n * @returns {*}\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n/**\n * Recursively concatenate two matrices.\n * The contents of the matrices is not cloned.\n * @param {Array} a             Multi dimensional array\n * @param {Array} b             Multi dimensional array\n * @param {number} concatDim    The dimension on which to concatenate (zero-based)\n * @param {number} dim          The current dim (zero-based)\n * @return {Array} c            The concatenated matrix\n * @private\n */\n\nfunction concatRecursive(a, b, concatDim, dim) {\n  if (dim < concatDim) {\n    // recurse into next dimension\n    if (a.length !== b.length) {\n      throw new DimensionError(a.length, b.length);\n    }\n\n    var c = [];\n\n    for (var i = 0; i < a.length; i++) {\n      c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);\n    }\n\n    return c;\n  } else {\n    // concatenate this dimension\n    return a.concat(b);\n  }\n}\n/**\n * Concatenates many arrays in the specified direction\n * @param {...Array} arrays All the arrays to concatenate\n * @param {number} concatDim The dimension on which to concatenate (zero-based)\n * @returns\n*/\n\n\nexport function concat() {\n  var arrays = Array.prototype.slice.call(arguments, 0, -1);\n  var concatDim = Array.prototype.slice.call(arguments, -1);\n\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n\n  if (arrays.length > 1) {\n    return arrays.slice(1).reduce(function (A, B) {\n      return concatRecursive(A, B, concatDim, 0);\n    }, arrays[0]);\n  } else {\n    throw new Error('Wrong number of arguments in function concat');\n  }\n}\n/**\n * Receives two or more sizes and get's the broadcasted size for both.\n * @param  {...number[]} sizes Sizes to broadcast together\n * @returns\n */\n\nexport function broadcastSizes() {\n  for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {\n    sizes[_key] = arguments[_key];\n  }\n\n  var dimensions = sizes.map(s => s.length);\n  var N = Math.max(...dimensions);\n  var sizeMax = new Array(N).fill(null); // check for every size\n\n  for (var i = 0; i < sizes.length; i++) {\n    var size = sizes[i];\n    var dim = dimensions[i];\n\n    for (var j = 0; j < dim; j++) {\n      var n = N - dim + j;\n\n      if (size[j] > sizeMax[n]) {\n        sizeMax[n] = size[j];\n      }\n    }\n  }\n\n  for (var _i = 0; _i < sizes.length; _i++) {\n    checkBroadcastingRules(sizes[_i], sizeMax);\n  }\n\n  return sizeMax;\n}\n/**\n * Checks if it's possible to broadcast a size to another size\n * @param {number[]} size The size of the array to check\n * @param {number[]} toSize The size of the array to validate if it can be broadcasted to\n */\n\nexport function checkBroadcastingRules(size, toSize) {\n  var N = toSize.length;\n  var dim = size.length;\n\n  for (var j = 0; j < dim; j++) {\n    var n = N - dim + j;\n\n    if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(size, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(size[j], \" to size \").concat(toSize[n]));\n    }\n  }\n}\n/**\n * Broadcasts a single array to a certain size\n * @param {array} array Array to be broadcasted\n * @param {number[]} toSize Size to broadcast the array\n * @returns The broadcasted array\n */\n\nexport function broadcastTo(array, toSize) {\n  var Asize = arraySize(array);\n\n  if (deepStrictEqual(Asize, toSize)) {\n    return array;\n  }\n\n  checkBroadcastingRules(Asize, toSize);\n  var broadcastedSize = broadcastSizes(Asize, toSize);\n  var N = broadcastedSize.length;\n  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];\n  var A = clone(array); // reshape A if needed to make it ready for concat\n\n  if (Asize.length < N) {\n    A = reshape(A, paddedSize);\n    Asize = arraySize(A);\n  } // stretches the array on each dimension to make it the same size as index\n\n\n  for (var dim = 0; dim < N; dim++) {\n    if (Asize[dim] < broadcastedSize[dim]) {\n      A = stretch(A, broadcastedSize[dim], dim);\n      Asize = arraySize(A);\n    }\n  }\n\n  return A;\n}\n/**\n * Broadcasts arrays and returns the broadcasted arrays in an array\n * @param  {...Array | any} arrays\n * @returns\n */\n\nexport function broadcastArrays() {\n  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = arguments[_key2];\n  }\n\n  if (arrays.length === 0) {\n    throw new Error('Insuficient number of argumnets in function broadcastArrays');\n  }\n\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n\n  var sizes = arrays.map(function (array) {\n    return arraySize(array);\n  });\n  var broadcastedSize = broadcastSizes(...sizes);\n  var broadcastedArrays = [];\n  arrays.forEach(function (array) {\n    broadcastedArrays.push(broadcastTo(array, broadcastedSize));\n  });\n  return broadcastedArrays;\n}\n/**\n * stretches a matrix up to a certain size in a certain dimension\n * @param {Array} arrayToStretch\n * @param {number[]} sizeToStretch\n * @param {number} dimToStretch\n * @returns\n */\n\nexport function stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n}\n/**\n * Deep clones a multidimensional array\n * @param {Array} array\n * @returns cloned array\n */\n\nexport function clone(array) {\n  return _extends([], array);\n}","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/utils/array.js"],"names":["_extends","isInteger","isNumber","isBigNumber","isArray","isString","format","DimensionError","IndexError","deepStrictEqual","arraySize","x","s","Array","push","length","_validate","array","size","dim","i","len","dimNext","child","validate","isScalar","validateIndexSourceSize","value","index","valueSize","isMatrix","_size","sourceSize","_sourceSize","forEach","sourceDim","validateIndex","undefined","TypeError","isEmptyIndex","_dimensions","dimension","_data","isRange","start","end","resize","defaultValue","Error","_defaultValue","_resize","elem","oldLen","newLen","minLen","Math","min","reshape","sizes","flatArray","flatten","currentLength","processSizesWildcard","newLength","product","_reshape","e","processedSizes","slice","WILDCARD","wildCardIndex","indexOf","isMoreThanOneWildcard","hasWildcard","canReplaceWildcard","reduce","prev","curr","tmpArray","tmpArray2","sizeIndex","squeeze","shift","dims","_squeeze","ii","next","unsqueeze","outer","unshift","_unsqueeze","d","flat","callback","map","prototype","call","filter","filterRegExp","regexp","entry","test","join","separator","identify","a","b","count","identifier","generalize","getArrayDataType","typeOf","type","item","_isArray","itemType","last","initial","contains","concatRecursive","concatDim","c","concat","arrays","arguments","A","B","broadcastSizes","_len","_key","dimensions","N","max","sizeMax","fill","j","n","_i","checkBroadcastingRules","toSize","broadcastTo","Asize","broadcastedSize","paddedSize","clone","stretch","broadcastArrays","_len2","_key2","broadcastedArrays","arrayToStretch","sizeToStretch","dimToStretch"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,gCAArB;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,QAAT,EAAmBC,WAAnB,EAAgCC,OAAhC,EAAyCC,QAAzC,QAAyD,SAAzD;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,cAAT,QAA+B,4BAA/B;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,eAAT,QAAgC,aAAhC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,CAAnB,EAAsB;AAC3B,MAAIC,CAAC,GAAG,EAAR;;AACA,SAAOC,KAAK,CAACT,OAAN,CAAcO,CAAd,CAAP,EAAyB;AACvBC,IAAAA,CAAC,CAACE,IAAF,CAAOH,CAAC,CAACI,MAAT;AACAJ,IAAAA,CAAC,GAAGA,CAAC,CAAC,CAAD,CAAL;AACD;;AACD,SAAOC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASI,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,GAAhC,EAAqC;AACnC,MAAIC,CAAJ;AACA,MAAIC,GAAG,GAAGJ,KAAK,CAACF,MAAhB;;AACA,MAAIM,GAAG,KAAKH,IAAI,CAACC,GAAD,CAAhB,EAAuB;AACrB,UAAM,IAAIZ,cAAJ,CAAmBc,GAAnB,EAAwBH,IAAI,CAACC,GAAD,CAA5B,CAAN;AACD;;AACD,MAAIA,GAAG,GAAGD,IAAI,CAACH,MAAL,GAAc,CAAxB,EAA2B;AACzB;AACA,QAAIO,OAAO,GAAGH,GAAG,GAAG,CAApB;;AACA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,GAAhB,EAAqBD,CAAC,EAAtB,EAA0B;AACxB,UAAIG,KAAK,GAAGN,KAAK,CAACG,CAAD,CAAjB;;AACA,UAAI,CAACP,KAAK,CAACT,OAAN,CAAcmB,KAAd,CAAL,EAA2B;AACzB,cAAM,IAAIhB,cAAJ,CAAmBW,IAAI,CAACH,MAAL,GAAc,CAAjC,EAAoCG,IAAI,CAACH,MAAzC,EAAiD,GAAjD,CAAN;AACD;;AACDC,MAAAA,SAAS,CAACC,KAAK,CAACG,CAAD,CAAN,EAAWF,IAAX,EAAiBI,OAAjB,CAAT;AACD;AACF,GAVD,MAUO;AACL;AACA,SAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,GAAhB,EAAqBD,CAAC,EAAtB,EAA0B;AACxB,UAAIP,KAAK,CAACT,OAAN,CAAca,KAAK,CAACG,CAAD,CAAnB,CAAJ,EAA6B;AAC3B,cAAM,IAAIb,cAAJ,CAAmBW,IAAI,CAACH,MAAL,GAAc,CAAjC,EAAoCG,IAAI,CAACH,MAAzC,EAAiD,GAAjD,CAAN;AACD;AACF;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASS,QAAT,CAAkBP,KAAlB,EAAyBC,IAAzB,EAA+B;AACpC,MAAIO,QAAQ,GAAGP,IAAI,CAACH,MAAL,KAAgB,CAA/B;;AACA,MAAIU,QAAJ,EAAc;AACZ;AACA,QAAIZ,KAAK,CAACT,OAAN,CAAca,KAAd,CAAJ,EAA0B;AACxB,YAAM,IAAIV,cAAJ,CAAmBU,KAAK,CAACF,MAAzB,EAAiC,CAAjC,CAAN;AACD;AACF,GALD,MAKO;AACL;AACAC,IAAAA,SAAS,CAACC,KAAD,EAAQC,IAAR,EAAc,CAAd,CAAT;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,uBAAT,CAAiCC,KAAjC,EAAwCC,KAAxC,EAA+C;AACpD,MAAIC,SAAS,GAAGF,KAAK,CAACG,QAAN,GAAiBH,KAAK,CAACI,KAAvB,GAA+BrB,SAAS,CAACiB,KAAD,CAAxD;AACA,MAAIK,UAAU,GAAGJ,KAAK,CAACK,WAAvB,CAFoD,CAGpD;;AACAD,EAAAA,UAAU,CAACE,OAAX,CAAmB,CAACC,SAAD,EAAYf,CAAZ,KAAkB;AACnC,QAAIe,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKN,SAAS,CAACT,CAAD,CAAjD,EAAsD;AACpD,YAAM,IAAIb,cAAJ,CAAmB4B,SAAnB,EAA8BN,SAAS,CAACT,CAAD,CAAvC,CAAN;AACD;AACF,GAJD;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgB,aAAT,CAAuBR,KAAvB,EAA8Bb,MAA9B,EAAsC;AAC3C,MAAIa,KAAK,KAAKS,SAAd,EAAyB;AACvB,QAAI,CAACnC,QAAQ,CAAC0B,KAAD,CAAT,IAAoB,CAAC3B,SAAS,CAAC2B,KAAD,CAAlC,EAA2C;AACzC,YAAM,IAAIU,SAAJ,CAAc,sCAAsCV,KAAtC,GAA8C,GAA5D,CAAN;AACD;;AACD,QAAIA,KAAK,GAAG,CAAR,IAAa,OAAOb,MAAP,KAAkB,QAAlB,IAA8Ba,KAAK,IAAIb,MAAxD,EAAgE;AAC9D,YAAM,IAAIP,UAAJ,CAAeoB,KAAf,EAAsBb,MAAtB,CAAN;AACD;AACF;AACF;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASwB,YAAT,CAAsBX,KAAtB,EAA6B;AAClC,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,KAAK,CAACY,WAAN,CAAkBzB,MAAtC,EAA8C,EAAEK,CAAhD,EAAmD;AACjD,QAAIqB,SAAS,GAAGb,KAAK,CAACY,WAAN,CAAkBpB,CAAlB,CAAhB;;AACA,QAAIqB,SAAS,CAACC,KAAV,IAAmBtC,OAAO,CAACqC,SAAS,CAACC,KAAX,CAA9B,EAAiD;AAC/C,UAAID,SAAS,CAACV,KAAV,CAAgB,CAAhB,MAAuB,CAA3B,EAA8B;AAC5B,eAAO,IAAP;AACD;AACF,KAJD,MAIO,IAAIU,SAAS,CAACE,OAAd,EAAuB;AAC5B,UAAIF,SAAS,CAACG,KAAV,KAAoBH,SAAS,CAACI,GAAlC,EAAuC;AACrC,eAAO,IAAP;AACD;AACF,KAJM,MAIA,IAAIxC,QAAQ,CAACoC,SAAD,CAAZ,EAAyB;AAC9B,UAAIA,SAAS,CAAC1B,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,eAAO,IAAP;AACD;AACF;AACF;;AACD,SAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS+B,MAAT,CAAgB7B,KAAhB,EAAuBC,IAAvB,EAA6B6B,YAA7B,EAA2C;AAChD;AACA,MAAI,CAAClC,KAAK,CAACT,OAAN,CAAcc,IAAd,CAAL,EAA0B;AACxB,UAAM,IAAIoB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,MAAIpB,IAAI,CAACH,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIiC,KAAJ,CAAU,qCAAV,CAAN;AACD,GAP+C,CAShD;;;AACA9B,EAAAA,IAAI,CAACgB,OAAL,CAAa,UAAUP,KAAV,EAAiB;AAC5B,QAAI,CAACzB,QAAQ,CAACyB,KAAD,CAAT,IAAoB,CAAC1B,SAAS,CAAC0B,KAAD,CAA9B,IAAyCA,KAAK,GAAG,CAArD,EAAwD;AACtD,YAAM,IAAIW,SAAJ,CAAc,kDAAkD,SAAlD,GAA8DhC,MAAM,CAACY,IAAD,CAApE,GAA6E,GAA3F,CAAN;AACD;AACF,GAJD,EAVgD,CAgBhD;;AACA,MAAIhB,QAAQ,CAACe,KAAD,CAAR,IAAmBd,WAAW,CAACc,KAAD,CAAlC,EAA2C;AACzCA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD,GAnB+C,CAqBhD;;;AACA,MAAIgC,aAAa,GAAGF,YAAY,KAAKV,SAAjB,GAA6BU,YAA7B,GAA4C,CAAhE;;AACAG,EAAAA,OAAO,CAACjC,KAAD,EAAQC,IAAR,EAAc,CAAd,EAAiB+B,aAAjB,CAAP;;AACA,SAAOhC,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASiC,OAAT,CAAiBjC,KAAjB,EAAwBC,IAAxB,EAA8BC,GAA9B,EAAmC4B,YAAnC,EAAiD;AAC/C,MAAI3B,CAAJ;AACA,MAAI+B,IAAJ;AACA,MAAIC,MAAM,GAAGnC,KAAK,CAACF,MAAnB;AACA,MAAIsC,MAAM,GAAGnC,IAAI,CAACC,GAAD,CAAjB;AACA,MAAImC,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASJ,MAAT,EAAiBC,MAAjB,CAAb,CAL+C,CAO/C;;AACApC,EAAAA,KAAK,CAACF,MAAN,GAAesC,MAAf;;AACA,MAAIlC,GAAG,GAAGD,IAAI,CAACH,MAAL,GAAc,CAAxB,EAA2B;AACzB;AACA,QAAIO,OAAO,GAAGH,GAAG,GAAG,CAApB,CAFyB,CAIzB;;AACA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkC,MAAhB,EAAwBlC,CAAC,EAAzB,EAA6B;AAC3B;AACA+B,MAAAA,IAAI,GAAGlC,KAAK,CAACG,CAAD,CAAZ;;AACA,UAAI,CAACP,KAAK,CAACT,OAAN,CAAc+C,IAAd,CAAL,EAA0B;AACxBA,QAAAA,IAAI,GAAG,CAACA,IAAD,CAAP,CADwB,CACT;;AACflC,QAAAA,KAAK,CAACG,CAAD,CAAL,GAAW+B,IAAX;AACD;;AACDD,MAAAA,OAAO,CAACC,IAAD,EAAOjC,IAAP,EAAaI,OAAb,EAAsByB,YAAtB,CAAP;AACD,KAbwB,CAezB;;;AACA,SAAK3B,CAAC,GAAGkC,MAAT,EAAiBlC,CAAC,GAAGiC,MAArB,EAA6BjC,CAAC,EAA9B,EAAkC;AAChC;AACA+B,MAAAA,IAAI,GAAG,EAAP;AACAlC,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAW+B,IAAX,CAHgC,CAKhC;;AACAD,MAAAA,OAAO,CAACC,IAAD,EAAOjC,IAAP,EAAaI,OAAb,EAAsByB,YAAtB,CAAP;AACD;AACF,GAxBD,MAwBO;AACL;AAEA;AACA,SAAK3B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkC,MAAhB,EAAwBlC,CAAC,EAAzB,EAA6B;AAC3B,aAAOP,KAAK,CAACT,OAAN,CAAca,KAAK,CAACG,CAAD,CAAnB,CAAP,EAAgC;AAC9BH,QAAAA,KAAK,CAACG,CAAD,CAAL,GAAWH,KAAK,CAACG,CAAD,CAAL,CAAS,CAAT,CAAX;AACD;AACF,KARI,CAUL;;;AACA,SAAKA,CAAC,GAAGkC,MAAT,EAAiBlC,CAAC,GAAGiC,MAArB,EAA6BjC,CAAC,EAA9B,EAAkC;AAChCH,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAW2B,YAAX;AACD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASU,OAAT,CAAiBxC,KAAjB,EAAwByC,KAAxB,EAA+B;AACpC,MAAIC,SAAS,GAAGC,OAAO,CAAC3C,KAAD,CAAvB;AACA,MAAI4C,aAAa,GAAGF,SAAS,CAAC5C,MAA9B;;AACA,MAAI,CAACF,KAAK,CAACT,OAAN,CAAca,KAAd,CAAD,IAAyB,CAACJ,KAAK,CAACT,OAAN,CAAcsD,KAAd,CAA9B,EAAoD;AAClD,UAAM,IAAIpB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,MAAIoB,KAAK,CAAC3C,MAAN,KAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIR,cAAJ,CAAmB,CAAnB,EAAsBsD,aAAtB,EAAqC,IAArC,CAAN;AACD;;AACDH,EAAAA,KAAK,GAAGI,oBAAoB,CAACJ,KAAD,EAAQG,aAAR,CAA5B;AACA,MAAIE,SAAS,GAAGC,OAAO,CAACN,KAAD,CAAvB;;AACA,MAAIG,aAAa,KAAKE,SAAtB,EAAiC;AAC/B,UAAM,IAAIxD,cAAJ,CAAmBwD,SAAnB,EAA8BF,aAA9B,EAA6C,IAA7C,CAAN;AACD;;AACD,MAAI;AACF,WAAOI,QAAQ,CAACN,SAAD,EAAYD,KAAZ,CAAf;AACD,GAFD,CAEE,OAAOQ,CAAP,EAAU;AACV,QAAIA,CAAC,YAAY3D,cAAjB,EAAiC;AAC/B,YAAM,IAAIA,cAAJ,CAAmBwD,SAAnB,EAA8BF,aAA9B,EAA6C,IAA7C,CAAN;AACD;;AACD,UAAMK,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASJ,oBAAT,CAA8BJ,KAA9B,EAAqCG,aAArC,EAAoD;AACzD,MAAIE,SAAS,GAAGC,OAAO,CAACN,KAAD,CAAvB;AACA,MAAIS,cAAc,GAAGT,KAAK,CAACU,KAAN,EAArB;AACA,MAAIC,QAAQ,GAAG,CAAC,CAAhB;AACA,MAAIC,aAAa,GAAGZ,KAAK,CAACa,OAAN,CAAcF,QAAd,CAApB;AACA,MAAIG,qBAAqB,GAAGd,KAAK,CAACa,OAAN,CAAcF,QAAd,EAAwBC,aAAa,GAAG,CAAxC,KAA8C,CAA1E;;AACA,MAAIE,qBAAJ,EAA2B;AACzB,UAAM,IAAIxB,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,MAAIyB,WAAW,GAAGH,aAAa,IAAI,CAAnC;AACA,MAAII,kBAAkB,GAAGb,aAAa,GAAGE,SAAhB,KAA8B,CAAvD;;AACA,MAAIU,WAAJ,EAAiB;AACf,QAAIC,kBAAJ,EAAwB;AACtBP,MAAAA,cAAc,CAACG,aAAD,CAAd,GAAgC,CAACT,aAAD,GAAiBE,SAAjD;AACD,KAFD,MAEO;AACL,YAAM,IAAIf,KAAJ,CAAU,uCAAuCa,aAAvC,GAAuD,qBAAvD,GAA+E,CAACE,SAA1F,CAAN;AACD;AACF;;AACD,SAAOI,cAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,SAASH,OAAT,CAAiB/C,KAAjB,EAAwB;AACtB,SAAOA,KAAK,CAAC0D,MAAN,CAAa,CAACC,IAAD,EAAOC,IAAP,KAAgBD,IAAI,GAAGC,IAApC,EAA0C,CAA1C,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASZ,QAAT,CAAkBhD,KAAlB,EAAyByC,KAAzB,EAAgC;AAC9B;AACA,MAAIoB,QAAQ,GAAG7D,KAAf;AACA,MAAI8D,SAAJ,CAH8B,CAI9B;;AACA,OAAK,IAAIC,SAAS,GAAGtB,KAAK,CAAC3C,MAAN,GAAe,CAApC,EAAuCiE,SAAS,GAAG,CAAnD,EAAsDA,SAAS,EAA/D,EAAmE;AACjE,QAAI9D,IAAI,GAAGwC,KAAK,CAACsB,SAAD,CAAhB;AACAD,IAAAA,SAAS,GAAG,EAAZ,CAFiE,CAIjE;;AACA,QAAIhE,MAAM,GAAG+D,QAAQ,CAAC/D,MAAT,GAAkBG,IAA/B;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAApB,EAA4BK,CAAC,EAA7B,EAAiC;AAC/B2D,MAAAA,SAAS,CAACjE,IAAV,CAAegE,QAAQ,CAACV,KAAT,CAAehD,CAAC,GAAGF,IAAnB,EAAyB,CAACE,CAAC,GAAG,CAAL,IAAUF,IAAnC,CAAf;AACD,KARgE,CASjE;;;AACA4D,IAAAA,QAAQ,GAAGC,SAAX;AACD;;AACD,SAAOD,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASG,OAAT,CAAiBhE,KAAjB,EAAwBC,IAAxB,EAA8B;AACnC,MAAIN,CAAC,GAAGM,IAAI,IAAIR,SAAS,CAACO,KAAD,CAAzB,CADmC,CAGnC;;AACA,SAAOJ,KAAK,CAACT,OAAN,CAAca,KAAd,KAAwBA,KAAK,CAACF,MAAN,KAAiB,CAAhD,EAAmD;AACjDE,IAAAA,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;AACAL,IAAAA,CAAC,CAACsE,KAAF;AACD,GAPkC,CASnC;;;AACA,MAAIC,IAAI,GAAGvE,CAAC,CAACG,MAAb;;AACA,SAAOH,CAAC,CAACuE,IAAI,GAAG,CAAR,CAAD,KAAgB,CAAvB,EAA0B;AACxBA,IAAAA,IAAI;AACL,GAbkC,CAenC;;;AACA,MAAIA,IAAI,GAAGvE,CAAC,CAACG,MAAb,EAAqB;AACnBE,IAAAA,KAAK,GAAGmE,QAAQ,CAACnE,KAAD,EAAQkE,IAAR,EAAc,CAAd,CAAhB;AACAvE,IAAAA,CAAC,CAACG,MAAF,GAAWoE,IAAX;AACD;;AACD,SAAOlE,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASmE,QAAT,CAAkBnE,KAAlB,EAAyBkE,IAAzB,EAA+BhE,GAA/B,EAAoC;AAClC,MAAIC,CAAJ,EAAOiE,EAAP;;AACA,MAAIlE,GAAG,GAAGgE,IAAV,EAAgB;AACd,QAAIG,IAAI,GAAGnE,GAAG,GAAG,CAAjB;;AACA,SAAKC,CAAC,GAAG,CAAJ,EAAOiE,EAAE,GAAGpE,KAAK,CAACF,MAAvB,EAA+BK,CAAC,GAAGiE,EAAnC,EAAuCjE,CAAC,EAAxC,EAA4C;AAC1CH,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAWgE,QAAQ,CAACnE,KAAK,CAACG,CAAD,CAAN,EAAW+D,IAAX,EAAiBG,IAAjB,CAAnB;AACD;AACF,GALD,MAKO;AACL,WAAOzE,KAAK,CAACT,OAAN,CAAca,KAAd,CAAP,EAA6B;AAC3BA,MAAAA,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;AACD;AACF;;AACD,SAAOA,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASsE,SAAT,CAAmBtE,KAAnB,EAA0BkE,IAA1B,EAAgCK,KAAhC,EAAuCtE,IAAvC,EAA6C;AAClD,MAAIN,CAAC,GAAGM,IAAI,IAAIR,SAAS,CAACO,KAAD,CAAzB,CADkD,CAGlD;;AACA,MAAIuE,KAAJ,EAAW;AACT,SAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoE,KAApB,EAA2BpE,CAAC,EAA5B,EAAgC;AAC9BH,MAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACAL,MAAAA,CAAC,CAAC6E,OAAF,CAAU,CAAV;AACD;AACF,GATiD,CAWlD;;;AACAxE,EAAAA,KAAK,GAAGyE,UAAU,CAACzE,KAAD,EAAQkE,IAAR,EAAc,CAAd,CAAlB;;AACA,SAAOvE,CAAC,CAACG,MAAF,GAAWoE,IAAlB,EAAwB;AACtBvE,IAAAA,CAAC,CAACE,IAAF,CAAO,CAAP;AACD;;AACD,SAAOG,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASyE,UAAT,CAAoBzE,KAApB,EAA2BkE,IAA3B,EAAiChE,GAAjC,EAAsC;AACpC,MAAIC,CAAJ,EAAOiE,EAAP;;AACA,MAAIxE,KAAK,CAACT,OAAN,CAAca,KAAd,CAAJ,EAA0B;AACxB,QAAIqE,IAAI,GAAGnE,GAAG,GAAG,CAAjB;;AACA,SAAKC,CAAC,GAAG,CAAJ,EAAOiE,EAAE,GAAGpE,KAAK,CAACF,MAAvB,EAA+BK,CAAC,GAAGiE,EAAnC,EAAuCjE,CAAC,EAAxC,EAA4C;AAC1CH,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAWsE,UAAU,CAACzE,KAAK,CAACG,CAAD,CAAN,EAAW+D,IAAX,EAAiBG,IAAjB,CAArB;AACD;AACF,GALD,MAKO;AACL,SAAK,IAAIK,CAAC,GAAGxE,GAAb,EAAkBwE,CAAC,GAAGR,IAAtB,EAA4BQ,CAAC,EAA7B,EAAiC;AAC/B1E,MAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;AACF;;AACD,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAS2C,OAAT,CAAiB3C,KAAjB,EAAwB;AAC7B,MAAI,CAACJ,KAAK,CAACT,OAAN,CAAca,KAAd,CAAL,EAA2B;AACzB;AACA,WAAOA,KAAP;AACD;;AACD,MAAI2E,IAAI,GAAG,EAAX;AACA3E,EAAAA,KAAK,CAACiB,OAAN,CAAc,SAAS2D,QAAT,CAAkBlE,KAAlB,EAAyB;AACrC,QAAId,KAAK,CAACT,OAAN,CAAcuB,KAAd,CAAJ,EAA0B;AACxBA,MAAAA,KAAK,CAACO,OAAN,CAAc2D,QAAd,EADwB,CACC;AAC1B,KAFD,MAEO;AACLD,MAAAA,IAAI,CAAC9E,IAAL,CAAUa,KAAV;AACD;AACF,GAND;AAOA,SAAOiE,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,GAAT,CAAa7E,KAAb,EAAoB4E,QAApB,EAA8B;AACnC,SAAOhF,KAAK,CAACkF,SAAN,CAAgBD,GAAhB,CAAoBE,IAApB,CAAyB/E,KAAzB,EAAgC4E,QAAhC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS3D,OAAT,CAAiBjB,KAAjB,EAAwB4E,QAAxB,EAAkC;AACvChF,EAAAA,KAAK,CAACkF,SAAN,CAAgB7D,OAAhB,CAAwB8D,IAAxB,CAA6B/E,KAA7B,EAAoC4E,QAApC;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,MAAT,CAAgBhF,KAAhB,EAAuB4E,QAAvB,EAAiC;AACtC,MAAInF,SAAS,CAACO,KAAD,CAAT,CAAiBF,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,UAAM,IAAIiC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,SAAOnC,KAAK,CAACkF,SAAN,CAAgBE,MAAhB,CAAuBD,IAAvB,CAA4B/E,KAA5B,EAAmC4E,QAAnC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,YAAT,CAAsBjF,KAAtB,EAA6BkF,MAA7B,EAAqC;AAC1C,MAAIzF,SAAS,CAACO,KAAD,CAAT,CAAiBF,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,UAAM,IAAIiC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,SAAOnC,KAAK,CAACkF,SAAN,CAAgBE,MAAhB,CAAuBD,IAAvB,CAA4B/E,KAA5B,EAAmCmF,KAAK,IAAID,MAAM,CAACE,IAAP,CAAYD,KAAZ,CAA5C,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,IAAT,CAAcrF,KAAd,EAAqBsF,SAArB,EAAgC;AACrC,SAAO1F,KAAK,CAACkF,SAAN,CAAgBO,IAAhB,CAAqBN,IAArB,CAA0B/E,KAA1B,EAAiCsF,SAAjC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,CAAlB,EAAqB;AAC1B,MAAI,CAAC5F,KAAK,CAACT,OAAN,CAAcqG,CAAd,CAAL,EAAuB;AACrB,UAAM,IAAInE,SAAJ,CAAc,sBAAd,CAAN;AACD;;AACD,MAAImE,CAAC,CAAC1F,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAO0F,CAAP;AACD;;AACD,MAAIC,CAAC,GAAG,EAAR;AACA,MAAIC,KAAK,GAAG,CAAZ;AACAD,EAAAA,CAAC,CAAC,CAAD,CAAD,GAAO;AACL/E,IAAAA,KAAK,EAAE8E,CAAC,CAAC,CAAD,CADH;AAELG,IAAAA,UAAU,EAAE;AAFP,GAAP;;AAIA,OAAK,IAAIxF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqF,CAAC,CAAC1F,MAAtB,EAA8BK,CAAC,EAA/B,EAAmC;AACjC,QAAIqF,CAAC,CAACrF,CAAD,CAAD,KAASqF,CAAC,CAACrF,CAAC,GAAG,CAAL,CAAd,EAAuB;AACrBuF,MAAAA,KAAK;AACN,KAFD,MAEO;AACLA,MAAAA,KAAK,GAAG,CAAR;AACD;;AACDD,IAAAA,CAAC,CAAC5F,IAAF,CAAO;AACLa,MAAAA,KAAK,EAAE8E,CAAC,CAACrF,CAAD,CADH;AAELwF,MAAAA,UAAU,EAAED;AAFP,KAAP;AAID;;AACD,SAAOD,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,UAAT,CAAoBJ,CAApB,EAAuB;AAC5B,MAAI,CAAC5F,KAAK,CAACT,OAAN,CAAcqG,CAAd,CAAL,EAAuB;AACrB,UAAM,IAAInE,SAAJ,CAAc,sBAAd,CAAN;AACD;;AACD,MAAImE,CAAC,CAAC1F,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAO0F,CAAP;AACD;;AACD,MAAIC,CAAC,GAAG,EAAR;;AACA,OAAK,IAAItF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqF,CAAC,CAAC1F,MAAtB,EAA8BK,CAAC,EAA/B,EAAmC;AACjCsF,IAAAA,CAAC,CAAC5F,IAAF,CAAO2F,CAAC,CAACrF,CAAD,CAAD,CAAKO,KAAZ;AACD;;AACD,SAAO+E,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,gBAAT,CAA0B7F,KAA1B,EAAiC8F,MAAjC,EAAyC;AAC9C,MAAIC,IAAJ,CAD8C,CACpC;;AACV,MAAIjG,MAAM,GAAG,CAAb,CAF8C,CAE9B;;AAEhB,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACF,MAA1B,EAAkCK,CAAC,EAAnC,EAAuC;AACrC,QAAI6F,IAAI,GAAGhG,KAAK,CAACG,CAAD,CAAhB;;AACA,QAAI8F,QAAQ,GAAGrG,KAAK,CAACT,OAAN,CAAc6G,IAAd,CAAf,CAFqC,CAIrC;;;AACA,QAAI7F,CAAC,KAAK,CAAN,IAAW8F,QAAf,EAAyB;AACvBnG,MAAAA,MAAM,GAAGkG,IAAI,CAAClG,MAAd;AACD,KAPoC,CASrC;;;AACA,QAAImG,QAAQ,IAAID,IAAI,CAAClG,MAAL,KAAgBA,MAAhC,EAAwC;AACtC,aAAOsB,SAAP;AACD;;AACD,QAAI8E,QAAQ,GAAGD,QAAQ,GAAGJ,gBAAgB,CAACG,IAAD,EAAOF,MAAP,CAAnB,CAAkC;AAAlC,MACrBA,MAAM,CAACE,IAAD,CADR;;AAEA,QAAID,IAAI,KAAK3E,SAAb,EAAwB;AACtB2E,MAAAA,IAAI,GAAGG,QAAP,CADsB,CACL;AAClB,KAFD,MAEO,IAAIH,IAAI,KAAKG,QAAb,EAAuB;AAC5B,aAAO,OAAP;AACD,KAFM,MAEA,CACL;AACD;AACF;;AACD,SAAOH,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,IAAT,CAAcnG,KAAd,EAAqB;AAC1B,SAAOA,KAAK,CAACA,KAAK,CAACF,MAAN,GAAe,CAAhB,CAAZ;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASsG,OAAT,CAAiBpG,KAAjB,EAAwB;AAC7B,SAAOA,KAAK,CAACmD,KAAN,CAAY,CAAZ,EAAenD,KAAK,CAACF,MAAN,GAAe,CAA9B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASuG,QAAT,CAAkBrG,KAAlB,EAAyBgG,IAAzB,EAA+B;AACpC,SAAOhG,KAAK,CAACsD,OAAN,CAAc0C,IAAd,MAAwB,CAAC,CAAhC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASM,eAAT,CAAyBd,CAAzB,EAA4BC,CAA5B,EAA+Bc,SAA/B,EAA0CrG,GAA1C,EAA+C;AAC7C,MAAIA,GAAG,GAAGqG,SAAV,EAAqB;AACnB;AACA,QAAIf,CAAC,CAAC1F,MAAF,KAAa2F,CAAC,CAAC3F,MAAnB,EAA2B;AACzB,YAAM,IAAIR,cAAJ,CAAmBkG,CAAC,CAAC1F,MAArB,EAA6B2F,CAAC,CAAC3F,MAA/B,CAAN;AACD;;AACD,QAAI0G,CAAC,GAAG,EAAR;;AACA,SAAK,IAAIrG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqF,CAAC,CAAC1F,MAAtB,EAA8BK,CAAC,EAA/B,EAAmC;AACjCqG,MAAAA,CAAC,CAACrG,CAAD,CAAD,GAAOmG,eAAe,CAACd,CAAC,CAACrF,CAAD,CAAF,EAAOsF,CAAC,CAACtF,CAAD,CAAR,EAAaoG,SAAb,EAAwBrG,GAAG,GAAG,CAA9B,CAAtB;AACD;;AACD,WAAOsG,CAAP;AACD,GAVD,MAUO;AACL;AACA,WAAOhB,CAAC,CAACiB,MAAF,CAAShB,CAAT,CAAP;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASgB,MAAT,GAAkB;AACvB,MAAIC,MAAM,GAAG9G,KAAK,CAACkF,SAAN,CAAgB3B,KAAhB,CAAsB4B,IAAtB,CAA2B4B,SAA3B,EAAsC,CAAtC,EAAyC,CAAC,CAA1C,CAAb;AACA,MAAIJ,SAAS,GAAG3G,KAAK,CAACkF,SAAN,CAAgB3B,KAAhB,CAAsB4B,IAAtB,CAA2B4B,SAA3B,EAAsC,CAAC,CAAvC,CAAhB;;AACA,MAAID,MAAM,CAAC5G,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO4G,MAAM,CAAC,CAAD,CAAb;AACD;;AACD,MAAIA,MAAM,CAAC5G,MAAP,GAAgB,CAApB,EAAuB;AACrB,WAAO4G,MAAM,CAACvD,KAAP,CAAa,CAAb,EAAgBO,MAAhB,CAAuB,UAAUkD,CAAV,EAAaC,CAAb,EAAgB;AAC5C,aAAOP,eAAe,CAACM,CAAD,EAAIC,CAAJ,EAAON,SAAP,EAAkB,CAAlB,CAAtB;AACD,KAFM,EAEJG,MAAM,CAAC,CAAD,CAFF,CAAP;AAGD,GAJD,MAIO;AACL,UAAM,IAAI3E,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS+E,cAAT,GAA0B;AAC/B,OAAK,IAAIC,IAAI,GAAGJ,SAAS,CAAC7G,MAArB,EAA6B2C,KAAK,GAAG,IAAI7C,KAAJ,CAAUmH,IAAV,CAArC,EAAsDC,IAAI,GAAG,CAAlE,EAAqEA,IAAI,GAAGD,IAA5E,EAAkFC,IAAI,EAAtF,EAA0F;AACxFvE,IAAAA,KAAK,CAACuE,IAAD,CAAL,GAAcL,SAAS,CAACK,IAAD,CAAvB;AACD;;AACD,MAAIC,UAAU,GAAGxE,KAAK,CAACoC,GAAN,CAAUlF,CAAC,IAAIA,CAAC,CAACG,MAAjB,CAAjB;AACA,MAAIoH,CAAC,GAAG5E,IAAI,CAAC6E,GAAL,CAAS,GAAGF,UAAZ,CAAR;AACA,MAAIG,OAAO,GAAG,IAAIxH,KAAJ,CAAUsH,CAAV,EAAaG,IAAb,CAAkB,IAAlB,CAAd,CAN+B,CAO/B;;AACA,OAAK,IAAIlH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,KAAK,CAAC3C,MAA1B,EAAkCK,CAAC,EAAnC,EAAuC;AACrC,QAAIF,IAAI,GAAGwC,KAAK,CAACtC,CAAD,CAAhB;AACA,QAAID,GAAG,GAAG+G,UAAU,CAAC9G,CAAD,CAApB;;AACA,SAAK,IAAImH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpH,GAApB,EAAyBoH,CAAC,EAA1B,EAA8B;AAC5B,UAAIC,CAAC,GAAGL,CAAC,GAAGhH,GAAJ,GAAUoH,CAAlB;;AACA,UAAIrH,IAAI,CAACqH,CAAD,CAAJ,GAAUF,OAAO,CAACG,CAAD,CAArB,EAA0B;AACxBH,QAAAA,OAAO,CAACG,CAAD,CAAP,GAAatH,IAAI,CAACqH,CAAD,CAAjB;AACD;AACF;AACF;;AACD,OAAK,IAAIE,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG/E,KAAK,CAAC3C,MAA5B,EAAoC0H,EAAE,EAAtC,EAA0C;AACxCC,IAAAA,sBAAsB,CAAChF,KAAK,CAAC+E,EAAD,CAAN,EAAYJ,OAAZ,CAAtB;AACD;;AACD,SAAOA,OAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,sBAAT,CAAgCxH,IAAhC,EAAsCyH,MAAtC,EAA8C;AACnD,MAAIR,CAAC,GAAGQ,MAAM,CAAC5H,MAAf;AACA,MAAII,GAAG,GAAGD,IAAI,CAACH,MAAf;;AACA,OAAK,IAAIwH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpH,GAApB,EAAyBoH,CAAC,EAA1B,EAA8B;AAC5B,QAAIC,CAAC,GAAGL,CAAC,GAAGhH,GAAJ,GAAUoH,CAAlB;;AACA,QAAIrH,IAAI,CAACqH,CAAD,CAAJ,GAAUI,MAAM,CAACH,CAAD,CAAhB,IAAuBtH,IAAI,CAACqH,CAAD,CAAJ,GAAU,CAAjC,IAAsCrH,IAAI,CAACqH,CAAD,CAAJ,GAAUI,MAAM,CAACH,CAAD,CAA1D,EAA+D;AAC7D,YAAM,IAAIxF,KAAJ,CAAU,0DAA0D0E,MAA1D,CAAiExG,IAAjE,EAAuE,wCAAvE,EAAiHwG,MAAjH,CAAwHvG,GAAxH,EAA6H,aAA7H,EAA4IuG,MAA5I,CAAmJxG,IAAI,CAACqH,CAAD,CAAvJ,EAA4J,WAA5J,EAAyKb,MAAzK,CAAgLiB,MAAM,CAACH,CAAD,CAAtL,CAAV,CAAN;AACD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,WAAT,CAAqB3H,KAArB,EAA4B0H,MAA5B,EAAoC;AACzC,MAAIE,KAAK,GAAGnI,SAAS,CAACO,KAAD,CAArB;;AACA,MAAIR,eAAe,CAACoI,KAAD,EAAQF,MAAR,CAAnB,EAAoC;AAClC,WAAO1H,KAAP;AACD;;AACDyH,EAAAA,sBAAsB,CAACG,KAAD,EAAQF,MAAR,CAAtB;AACA,MAAIG,eAAe,GAAGf,cAAc,CAACc,KAAD,EAAQF,MAAR,CAApC;AACA,MAAIR,CAAC,GAAGW,eAAe,CAAC/H,MAAxB;AACA,MAAIgI,UAAU,GAAG,CAAC,GAAGlI,KAAK,CAACsH,CAAC,GAAGU,KAAK,CAAC9H,MAAX,CAAL,CAAwBuH,IAAxB,CAA6B,CAA7B,CAAJ,EAAqC,GAAGO,KAAxC,CAAjB;AACA,MAAIhB,CAAC,GAAGmB,KAAK,CAAC/H,KAAD,CAAb,CATyC,CAUzC;;AACA,MAAI4H,KAAK,CAAC9H,MAAN,GAAeoH,CAAnB,EAAsB;AACpBN,IAAAA,CAAC,GAAGpE,OAAO,CAACoE,CAAD,EAAIkB,UAAJ,CAAX;AACAF,IAAAA,KAAK,GAAGnI,SAAS,CAACmH,CAAD,CAAjB;AACD,GAdwC,CAgBzC;;;AACA,OAAK,IAAI1G,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGgH,CAAxB,EAA2BhH,GAAG,EAA9B,EAAkC;AAChC,QAAI0H,KAAK,CAAC1H,GAAD,CAAL,GAAa2H,eAAe,CAAC3H,GAAD,CAAhC,EAAuC;AACrC0G,MAAAA,CAAC,GAAGoB,OAAO,CAACpB,CAAD,EAAIiB,eAAe,CAAC3H,GAAD,CAAnB,EAA0BA,GAA1B,CAAX;AACA0H,MAAAA,KAAK,GAAGnI,SAAS,CAACmH,CAAD,CAAjB;AACD;AACF;;AACD,SAAOA,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqB,eAAT,GAA2B;AAChC,OAAK,IAAIC,KAAK,GAAGvB,SAAS,CAAC7G,MAAtB,EAA8B4G,MAAM,GAAG,IAAI9G,KAAJ,CAAUsI,KAAV,CAAvC,EAAyDC,KAAK,GAAG,CAAtE,EAAyEA,KAAK,GAAGD,KAAjF,EAAwFC,KAAK,EAA7F,EAAiG;AAC/FzB,IAAAA,MAAM,CAACyB,KAAD,CAAN,GAAgBxB,SAAS,CAACwB,KAAD,CAAzB;AACD;;AACD,MAAIzB,MAAM,CAAC5G,MAAP,KAAkB,CAAtB,EAAyB;AACvB,UAAM,IAAIiC,KAAJ,CAAU,6DAAV,CAAN;AACD;;AACD,MAAI2E,MAAM,CAAC5G,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO4G,MAAM,CAAC,CAAD,CAAb;AACD;;AACD,MAAIjE,KAAK,GAAGiE,MAAM,CAAC7B,GAAP,CAAW,UAAU7E,KAAV,EAAiB;AACtC,WAAOP,SAAS,CAACO,KAAD,CAAhB;AACD,GAFW,CAAZ;AAGA,MAAI6H,eAAe,GAAGf,cAAc,CAAC,GAAGrE,KAAJ,CAApC;AACA,MAAI2F,iBAAiB,GAAG,EAAxB;AACA1B,EAAAA,MAAM,CAACzF,OAAP,CAAe,UAAUjB,KAAV,EAAiB;AAC9BoI,IAAAA,iBAAiB,CAACvI,IAAlB,CAAuB8H,WAAW,CAAC3H,KAAD,EAAQ6H,eAAR,CAAlC;AACD,GAFD;AAGA,SAAOO,iBAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASJ,OAAT,CAAiBK,cAAjB,EAAiCC,aAAjC,EAAgDC,YAAhD,EAA8D;AACnE,SAAO9B,MAAM,CAAC,GAAG7G,KAAK,CAAC0I,aAAD,CAAL,CAAqBjB,IAArB,CAA0BgB,cAA1B,CAAJ,EAA+CE,YAA/C,CAAb;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASR,KAAT,CAAe/H,KAAf,EAAsB;AAC3B,SAAOjB,QAAQ,CAAC,EAAD,EAAKiB,KAAL,CAAf;AACD","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport { isInteger } from './number.js';\nimport { isNumber, isBigNumber, isArray, isString } from './is.js';\nimport { format } from './string.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\nimport { deepStrictEqual } from './object.js';\n\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\nexport function arraySize(x) {\n  var s = [];\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n  return s;\n}\n\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n\n/**\n * Validate whether the source of the index matches the size of the Array\n * @param {Array | Matrix} array    Array to be validated\n * @param {Index} index  Index with the source information to validate\n * @throws DimensionError\n */\nexport function validateIndexSourceSize(value, index) {\n  var valueSize = value.isMatrix ? value._size : arraySize(value);\n  var sourceSize = index._sourceSize;\n  // checks if the source size is not null and matches the valueSize\n  sourceSize.forEach((sourceDim, i) => {\n    if (sourceDim !== null && sourceDim !== valueSize[i]) {\n      throw new DimensionError(sourceDim, valueSize[i]);\n    }\n  });\n}\n\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\nexport function validateIndex(index, length) {\n  if (index !== undefined) {\n    if (!isNumber(index) || !isInteger(index)) {\n      throw new TypeError('Index must be an integer (value: ' + index + ')');\n    }\n    if (index < 0 || typeof length === 'number' && index >= length) {\n      throw new IndexError(index, length);\n    }\n  }\n}\n\n/**\n * Test if and index has empty values\n * @param {number} index    Zero-based index\n */\nexport function isEmptyIndex(index) {\n  for (var i = 0; i < index._dimensions.length; ++i) {\n    var dimension = index._dimensions[i];\n    if (dimension._data && isArray(dimension._data)) {\n      if (dimension._size[0] === 0) {\n        return true;\n      }\n    } else if (dimension.isRange) {\n      if (dimension.start === dimension.end) {\n        return true;\n      }\n    } else if (isString(dimension)) {\n      if (dimension.length === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array | number} array         Array to be resized\n * @param {number[]} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\nexport function resize(array, size, defaultValue) {\n  // check the type of the arguments\n  if (!Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  }\n\n  // check whether size contains positive integers\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  });\n\n  // convert number to an array\n  if (isNumber(array) || isBigNumber(array)) {\n    array = [array];\n  }\n\n  // recursively resize the array\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n  _resize(array, size, 0, _defaultValue);\n  return array;\n}\n\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen);\n\n  // apply new length\n  array.length = newLen;\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1;\n\n    // resize existing child arrays\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n        array[i] = elem;\n      }\n      _resize(elem, size, dimNext, defaultValue);\n    }\n\n    // create new child arrays\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem;\n\n      // resize new child array\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    }\n\n    // fill new elements with the default value\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {number[]} sizes        List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n  if (sizes.length === 0) {\n    throw new DimensionError(0, currentLength, '!=');\n  }\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n  if (currentLength !== newLength) {\n    throw new DimensionError(newLength, currentLength, '!=');\n  }\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(newLength, currentLength, '!=');\n    }\n    throw e;\n  }\n}\n\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {number[]} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {number[]}      The sizes array with wildcard replaced.\n */\nexport function processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n  return processedSizes;\n}\n\n/**\n * Computes the product of all array elements.\n * @param {number[]} array Array of factors\n * @returns {number}            Product of all elements\n */\nfunction product(array) {\n  return array.reduce((prev, curr) => prev * curr, 1);\n}\n\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {number[]} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2;\n  // for each dimensions starting by the last one and ignoring the first one\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = [];\n\n    // aggregate the elements of the current tmpArray in elements of the requested size\n    var length = tmpArray.length / size;\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    }\n    // set it as the new tmpArray for the next loop turn or for return\n    tmpArray = tmpArray2;\n  }\n  return tmpArray;\n}\n\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\nexport function squeeze(array, size) {\n  var s = size || arraySize(array);\n\n  // squeeze outer dimensions\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  }\n\n  // find the first dimension to be squeezed\n  var dims = s.length;\n  while (s[dims - 1] === 1) {\n    dims--;\n  }\n\n  // squeeze inner dimensions\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n  return array;\n}\n\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n  if (dim < dims) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n  return array;\n}\n\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array);\n\n  // unsqueeze outer dimensions\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  }\n\n  // unsqueeze inner dimensions\n  array = _unsqueeze(array, dims, 0);\n  while (s.length < dims) {\n    s.push(1);\n  }\n  return array;\n}\n\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n  return Array.prototype.filter.call(array, callback);\n}\n\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n  return Array.prototype.filter.call(array, entry => regexp.test(entry));\n}\n\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n  if (a.length === 0) {\n    return a;\n  }\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n  return b;\n}\n\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n  if (a.length === 0) {\n    return a;\n  }\n  var b = [];\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n  return b;\n}\n\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var _isArray = Array.isArray(item);\n\n    // Saving the target matrix row size\n    if (i === 0 && _isArray) {\n      length = item.length;\n    }\n\n    // If the current item is an array but the length does not equal the targetVectorSize\n    if (_isArray && item.length !== length) {\n      return undefined;\n    }\n    var itemType = _isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {\n      // we're good, everything has the same type so far\n    }\n  }\n  return type;\n}\n\n/**\n * Return the last item from an array\n * @param {array}\n * @returns {*}\n */\nexport function last(array) {\n  return array[array.length - 1];\n}\n\n/**\n * Get all but the last element of array.\n * @param {array}\n * @returns {*}\n */\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\n/**\n * Recursively concatenate two matrices.\n * The contents of the matrices is not cloned.\n * @param {Array} a             Multi dimensional array\n * @param {Array} b             Multi dimensional array\n * @param {number} concatDim    The dimension on which to concatenate (zero-based)\n * @param {number} dim          The current dim (zero-based)\n * @return {Array} c            The concatenated matrix\n * @private\n */\nfunction concatRecursive(a, b, concatDim, dim) {\n  if (dim < concatDim) {\n    // recurse into next dimension\n    if (a.length !== b.length) {\n      throw new DimensionError(a.length, b.length);\n    }\n    var c = [];\n    for (var i = 0; i < a.length; i++) {\n      c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);\n    }\n    return c;\n  } else {\n    // concatenate this dimension\n    return a.concat(b);\n  }\n}\n\n/**\n * Concatenates many arrays in the specified direction\n * @param {...Array} arrays All the arrays to concatenate\n * @param {number} concatDim The dimension on which to concatenate (zero-based)\n * @returns\n*/\nexport function concat() {\n  var arrays = Array.prototype.slice.call(arguments, 0, -1);\n  var concatDim = Array.prototype.slice.call(arguments, -1);\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n  if (arrays.length > 1) {\n    return arrays.slice(1).reduce(function (A, B) {\n      return concatRecursive(A, B, concatDim, 0);\n    }, arrays[0]);\n  } else {\n    throw new Error('Wrong number of arguments in function concat');\n  }\n}\n\n/**\n * Receives two or more sizes and get's the broadcasted size for both.\n * @param  {...number[]} sizes Sizes to broadcast together\n * @returns\n */\nexport function broadcastSizes() {\n  for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {\n    sizes[_key] = arguments[_key];\n  }\n  var dimensions = sizes.map(s => s.length);\n  var N = Math.max(...dimensions);\n  var sizeMax = new Array(N).fill(null);\n  // check for every size\n  for (var i = 0; i < sizes.length; i++) {\n    var size = sizes[i];\n    var dim = dimensions[i];\n    for (var j = 0; j < dim; j++) {\n      var n = N - dim + j;\n      if (size[j] > sizeMax[n]) {\n        sizeMax[n] = size[j];\n      }\n    }\n  }\n  for (var _i = 0; _i < sizes.length; _i++) {\n    checkBroadcastingRules(sizes[_i], sizeMax);\n  }\n  return sizeMax;\n}\n\n/**\n * Checks if it's possible to broadcast a size to another size\n * @param {number[]} size The size of the array to check\n * @param {number[]} toSize The size of the array to validate if it can be broadcasted to\n */\nexport function checkBroadcastingRules(size, toSize) {\n  var N = toSize.length;\n  var dim = size.length;\n  for (var j = 0; j < dim; j++) {\n    var n = N - dim + j;\n    if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(size, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(size[j], \" to size \").concat(toSize[n]));\n    }\n  }\n}\n\n/**\n * Broadcasts a single array to a certain size\n * @param {array} array Array to be broadcasted\n * @param {number[]} toSize Size to broadcast the array\n * @returns The broadcasted array\n */\nexport function broadcastTo(array, toSize) {\n  var Asize = arraySize(array);\n  if (deepStrictEqual(Asize, toSize)) {\n    return array;\n  }\n  checkBroadcastingRules(Asize, toSize);\n  var broadcastedSize = broadcastSizes(Asize, toSize);\n  var N = broadcastedSize.length;\n  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];\n  var A = clone(array);\n  // reshape A if needed to make it ready for concat\n  if (Asize.length < N) {\n    A = reshape(A, paddedSize);\n    Asize = arraySize(A);\n  }\n\n  // stretches the array on each dimension to make it the same size as index\n  for (var dim = 0; dim < N; dim++) {\n    if (Asize[dim] < broadcastedSize[dim]) {\n      A = stretch(A, broadcastedSize[dim], dim);\n      Asize = arraySize(A);\n    }\n  }\n  return A;\n}\n\n/**\n * Broadcasts arrays and returns the broadcasted arrays in an array\n * @param  {...Array | any} arrays\n * @returns\n */\nexport function broadcastArrays() {\n  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = arguments[_key2];\n  }\n  if (arrays.length === 0) {\n    throw new Error('Insuficient number of argumnets in function broadcastArrays');\n  }\n  if (arrays.length === 1) {\n    return arrays[0];\n  }\n  var sizes = arrays.map(function (array) {\n    return arraySize(array);\n  });\n  var broadcastedSize = broadcastSizes(...sizes);\n  var broadcastedArrays = [];\n  arrays.forEach(function (array) {\n    broadcastedArrays.push(broadcastTo(array, broadcastedSize));\n  });\n  return broadcastedArrays;\n}\n\n/**\n * stretches a matrix up to a certain size in a certain dimension\n * @param {Array} arrayToStretch\n * @param {number[]} sizeToStretch\n * @param {number} dimToStretch\n * @returns\n */\nexport function stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n}\n\n/**\n * Deep clones a multidimensional array\n * @param {Array} array\n * @returns cloned array\n */\nexport function clone(array) {\n  return _extends([], array);\n}"]},"metadata":{},"sourceType":"module"}