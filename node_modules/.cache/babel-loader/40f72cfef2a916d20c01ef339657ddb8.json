{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n\n  class IndexNode extends Node {\n    /**\n     * @constructor IndexNode\n     * @extends Node\n     *\n     * Describes a subset of a matrix or an object property.\n     * Cannot be used on its own, needs to be used within an AccessorNode or\n     * AssignmentNode.\n     *\n     * @param {Node[]} dimensions\n     * @param {boolean} [dotNotation=false]\n     *     Optional property describing whether this index was written using dot\n     *     notation like `a.b`, or using bracket notation like `a[\"b\"]`\n     *     (which is the default). This property is used for string conversion.\n     */\n    constructor(dimensions, dotNotation) {\n      super();\n      this.dimensions = dimensions;\n      this.dotNotation = dotNotation || false; // validate input\n\n      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n      }\n\n      if (this.dotNotation && !this.isObjectProperty()) {\n        throw new Error('dotNotation only applicable for object properties');\n      }\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isIndexNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      // TODO: implement support for bignumber (currently bignumbers are silently\n      //       reduced to numbers when changing the value to zero-based)\n      // TODO: Optimization: when the range values are ConstantNodes,\n      //       we can beforehand resolve the zero-based value\n      // optimization for a simple object property\n      var evalDimensions = map(this.dimensions, function (dimension, i) {\n        var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n\n        if (needsEnd) {\n          // SymbolNode 'end' is used inside the index,\n          // like in `A[end]` or `A[end - 2]`\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var _evalDimension = dimension._compile(math, childArgNames);\n\n          return function evalDimension(scope, args, context) {\n            if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n              throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n            }\n\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return _evalDimension(scope, childArgs, context);\n          };\n        } else {\n          // SymbolNode `end` not used\n          return dimension._compile(math, argNames);\n        }\n      });\n      var index = getSafeProperty(math, 'index');\n      return function evalIndexNode(scope, args, context) {\n        var dimensions = map(evalDimensions, function (evalDimension) {\n          return evalDimension(scope, args, context);\n        });\n        return index(...dimensions);\n      };\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.dimensions.length; i++) {\n        callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new IndexNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {IndexNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var dimensions = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n      }\n\n      return new IndexNode(dimensions, this.dotNotation);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {IndexNode}\n     */\n\n\n    clone() {\n      return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n    }\n    /**\n     * Test whether this IndexNode contains a single property name\n     * @return {boolean}\n     */\n\n\n    isObjectProperty() {\n      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n    }\n    /**\n     * Returns the property name if IndexNode contains a property.\n     * If not, returns null.\n     * @return {string | null}\n     */\n\n\n    getObjectProperty() {\n      return this.isObjectProperty() ? this.dimensions[0].value : null;\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      // format the parameters like \"[1, 0:5]\"\n      return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        dimensions: this.dimensions,\n        dotNotation: this.dotNotation\n      };\n    }\n    /**\n     * Instantiate an IndexNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n     *     where mathjs is optional\n     * @returns {IndexNode}\n     */\n\n\n    static fromJSON(json) {\n      return new IndexNode(json.dimensions, json.dotNotation);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      // format the parameters like \"[1, 0:5]\"\n      var dimensions = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this.dimensions[i].toHTML();\n      }\n\n      if (this.dotNotation) {\n        return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n      } else {\n        return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n      }\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var dimensions = this.dimensions.map(function (range) {\n        return range.toTex(options);\n      });\n      return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n    }\n\n  }\n\n  _defineProperty(IndexNode, \"name\", name);\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"names":["_defineProperty","map","getSafeProperty","factory","isArray","isConstantNode","isMatrix","isNode","isString","typeOf","escape","name","dependencies","createIndexNode","_ref","Node","size","IndexNode","constructor","dimensions","dotNotation","Array","every","TypeError","isObjectProperty","Error","type","isIndexNode","_compile","math","argNames","evalDimensions","dimension","i","needsEnd","filter","node","isSymbolNode","length","childArgNames","Object","create","end","_evalDimension","evalDimension","scope","args","context","s","valueOf","childArgs","index","evalIndexNode","forEach","callback","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","range","toTex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n  class IndexNode extends Node {\n    /**\n     * @constructor IndexNode\n     * @extends Node\n     *\n     * Describes a subset of a matrix or an object property.\n     * Cannot be used on its own, needs to be used within an AccessorNode or\n     * AssignmentNode.\n     *\n     * @param {Node[]} dimensions\n     * @param {boolean} [dotNotation=false]\n     *     Optional property describing whether this index was written using dot\n     *     notation like `a.b`, or using bracket notation like `a[\"b\"]`\n     *     (which is the default). This property is used for string conversion.\n     */\n    constructor(dimensions, dotNotation) {\n      super();\n      this.dimensions = dimensions;\n      this.dotNotation = dotNotation || false;\n\n      // validate input\n      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n      }\n      if (this.dotNotation && !this.isObjectProperty()) {\n        throw new Error('dotNotation only applicable for object properties');\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isIndexNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      // TODO: implement support for bignumber (currently bignumbers are silently\n      //       reduced to numbers when changing the value to zero-based)\n\n      // TODO: Optimization: when the range values are ConstantNodes,\n      //       we can beforehand resolve the zero-based value\n\n      // optimization for a simple object property\n      var evalDimensions = map(this.dimensions, function (dimension, i) {\n        var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n        if (needsEnd) {\n          // SymbolNode 'end' is used inside the index,\n          // like in `A[end]` or `A[end - 2]`\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var _evalDimension = dimension._compile(math, childArgNames);\n          return function evalDimension(scope, args, context) {\n            if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n              throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n            }\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return _evalDimension(scope, childArgs, context);\n          };\n        } else {\n          // SymbolNode `end` not used\n          return dimension._compile(math, argNames);\n        }\n      });\n      var index = getSafeProperty(math, 'index');\n      return function evalIndexNode(scope, args, context) {\n        var dimensions = map(evalDimensions, function (evalDimension) {\n          return evalDimension(scope, args, context);\n        });\n        return index(...dimensions);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.dimensions.length; i++) {\n        callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new IndexNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {IndexNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n      }\n      return new IndexNode(dimensions, this.dotNotation);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {IndexNode}\n     */\n    clone() {\n      return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n    }\n\n    /**\n     * Test whether this IndexNode contains a single property name\n     * @return {boolean}\n     */\n    isObjectProperty() {\n      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n    }\n\n    /**\n     * Returns the property name if IndexNode contains a property.\n     * If not, returns null.\n     * @return {string | null}\n     */\n    getObjectProperty() {\n      return this.isObjectProperty() ? this.dimensions[0].value : null;\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      // format the parameters like \"[1, 0:5]\"\n      return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        dimensions: this.dimensions,\n        dotNotation: this.dotNotation\n      };\n    }\n\n    /**\n     * Instantiate an IndexNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n     *     where mathjs is optional\n     * @returns {IndexNode}\n     */\n    static fromJSON(json) {\n      return new IndexNode(json.dimensions, json.dotNotation);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      // format the parameters like \"[1, 0:5]\"\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this.dimensions[i].toHTML();\n      }\n      if (this.dotNotation) {\n        return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n      } else {\n        return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n      }\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var dimensions = this.dimensions.map(function (range) {\n        return range.toTex(options);\n      });\n      return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n    }\n  }\n  _defineProperty(IndexNode, \"name\", name);\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}