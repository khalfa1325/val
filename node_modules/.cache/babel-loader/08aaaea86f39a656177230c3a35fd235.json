{"ast":null,"code":"import typed from 'typed-function';\nimport { typeOf as _typeOf } from './is.js';\n/**\n * Invoke a callback for functions like map and filter with a matching number of arguments\n * @param {function} callback\n * @param {any} value\n * @param {number | number[]} index\n * @param {Array} array\n * @param {string} mappingFnName   The name of the function that is invoking these callbacks, for example \"map\" or \"filter\"\n * @returns {*}\n */\n\nexport function applyCallback(callback, value, index, array, mappingFnName) {\n  if (typed.isTypedFunction(callback)) {\n    // invoke the typed callback function with the matching number of arguments only\n    var args3 = [value, index, array];\n    var signature3 = typed.resolve(callback, args3);\n\n    if (signature3) {\n      return tryWithArgs(signature3.implementation, args3);\n    }\n\n    var args2 = [value, index];\n    var signature2 = typed.resolve(callback, args2);\n\n    if (signature2) {\n      return tryWithArgs(signature2.implementation, args2);\n    }\n\n    var args1 = [value];\n    var signature1 = typed.resolve(callback, args1);\n\n    if (signature1) {\n      return tryWithArgs(signature1.implementation, args1);\n    } // fallback (will throw an exception)\n\n\n    return tryWithArgs(callback, args3);\n  } else {\n    // A regular JavaScript function\n    return callback(value, index, array);\n  }\n  /**\n   * @param {function} signature The selected signature of the typed-function\n   * @param {Array} args List with arguments to apply to the selected signature\n   * @returns {*} Returns the return value of the invoked signature\n   * @throws {TypeError} Throws an error when no matching signature was found\n   */\n\n\n  function tryWithArgs(signature, args) {\n    try {\n      return signature.apply(signature, args);\n    } catch (err) {\n      var _err$data; // Enrich the error message so the user understands that it took place inside the callback function\n\n\n      if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === 'wrongType') {\n        var argsDesc = [];\n        argsDesc.push(\"value: \".concat(_typeOf(value)));\n\n        if (args.length >= 2) {\n          argsDesc.push(\"index: \".concat(_typeOf(index)));\n        }\n\n        if (args.length >= 3) {\n          argsDesc.push(\"array: \".concat(_typeOf(array)));\n        }\n\n        throw new TypeError(\"Function \".concat(mappingFnName, \" cannot apply callback arguments \") + \"\".concat(callback.name, \"(\").concat(argsDesc.join(', '), \") at index \").concat(JSON.stringify(index)));\n      } else {\n        throw new TypeError(\"Function \".concat(mappingFnName, \" cannot apply callback arguments \") + \"to function \".concat(callback.name, \": \").concat(err.message));\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/utils/applyCallback.js"],"names":["typed","typeOf","_typeOf","applyCallback","callback","value","index","array","mappingFnName","isTypedFunction","args3","signature3","resolve","tryWithArgs","implementation","args2","signature2","args1","signature1","signature","args","apply","err","_err$data","TypeError","data","category","argsDesc","push","concat","length","name","join","JSON","stringify","message"],"mappings":"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","sourcesContent":["import typed from 'typed-function';\nimport { typeOf as _typeOf } from './is.js';\n\n/**\n * Invoke a callback for functions like map and filter with a matching number of arguments\n * @param {function} callback\n * @param {any} value\n * @param {number | number[]} index\n * @param {Array} array\n * @param {string} mappingFnName   The name of the function that is invoking these callbacks, for example \"map\" or \"filter\"\n * @returns {*}\n */\nexport function applyCallback(callback, value, index, array, mappingFnName) {\n  if (typed.isTypedFunction(callback)) {\n    // invoke the typed callback function with the matching number of arguments only\n\n    var args3 = [value, index, array];\n    var signature3 = typed.resolve(callback, args3);\n    if (signature3) {\n      return tryWithArgs(signature3.implementation, args3);\n    }\n    var args2 = [value, index];\n    var signature2 = typed.resolve(callback, args2);\n    if (signature2) {\n      return tryWithArgs(signature2.implementation, args2);\n    }\n    var args1 = [value];\n    var signature1 = typed.resolve(callback, args1);\n    if (signature1) {\n      return tryWithArgs(signature1.implementation, args1);\n    }\n\n    // fallback (will throw an exception)\n    return tryWithArgs(callback, args3);\n  } else {\n    // A regular JavaScript function\n    return callback(value, index, array);\n  }\n\n  /**\n   * @param {function} signature The selected signature of the typed-function\n   * @param {Array} args List with arguments to apply to the selected signature\n   * @returns {*} Returns the return value of the invoked signature\n   * @throws {TypeError} Throws an error when no matching signature was found\n   */\n  function tryWithArgs(signature, args) {\n    try {\n      return signature.apply(signature, args);\n    } catch (err) {\n      var _err$data;\n      // Enrich the error message so the user understands that it took place inside the callback function\n      if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === 'wrongType') {\n        var argsDesc = [];\n        argsDesc.push(\"value: \".concat(_typeOf(value)));\n        if (args.length >= 2) {\n          argsDesc.push(\"index: \".concat(_typeOf(index)));\n        }\n        if (args.length >= 3) {\n          argsDesc.push(\"array: \".concat(_typeOf(array)));\n        }\n        throw new TypeError(\"Function \".concat(mappingFnName, \" cannot apply callback arguments \") + \"\".concat(callback.name, \"(\").concat(argsDesc.join(', '), \") at index \").concat(JSON.stringify(index)));\n      } else {\n        throw new TypeError(\"Function \".concat(mappingFnName, \" cannot apply callback arguments \") + \"to function \".concat(callback.name, \": \").concat(err.message));\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}