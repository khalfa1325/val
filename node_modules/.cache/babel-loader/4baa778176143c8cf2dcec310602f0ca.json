{"ast":null,"code":"import { factory } from '../utils/factory.js';\nimport { deepMap } from '../utils/collection.js';\nvar name = 'number';\nvar dependencies = ['typed'];\n/**\n * Separates the radix, integer part, and fractional part of a non decimal number string\n * @param {string} input string to parse\n * @returns {object} the parts of the string or null if not a valid input\n */\n\nfunction getNonDecimalNumberParts(input) {\n  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\\.([0-9a-fA-F]*)/);\n\n  if (nonDecimalWithRadixMatch) {\n    var radix = {\n      '0b': 2,\n      '0o': 8,\n      '0x': 16\n    }[nonDecimalWithRadixMatch[1]];\n    var integerPart = nonDecimalWithRadixMatch[2];\n    var fractionalPart = nonDecimalWithRadixMatch[3];\n    return {\n      input,\n      radix,\n      integerPart,\n      fractionalPart\n    };\n  } else {\n    return null;\n  }\n}\n/**\n * Makes a number from a radix, and integer part, and a fractional part\n * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)\n * @returns {number} the number\n */\n\n\nfunction makeNumberFromNonDecimalParts(parts) {\n  var n = parseInt(parts.integerPart, parts.radix);\n  var f = 0;\n\n  for (var i = 0; i < parts.fractionalPart.length; i++) {\n    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);\n    f += digitValue / Math.pow(parts.radix, i + 1);\n  }\n\n  var result = n + f;\n\n  if (isNaN(result)) {\n    throw new SyntaxError('String \"' + parts.input + '\" is no valid number');\n  }\n\n  return result;\n}\n\nexport var createNumber = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Create a number or convert a string, boolean, or unit to a number.\n   * When value is a matrix, all elements will be converted to number.\n   *\n   * Syntax:\n   *\n   *    math.number(value)\n   *    math.number(unit, valuelessUnit)\n   *\n   * Examples:\n   *\n   *    math.number(2)                         // returns number 2\n   *    math.number('7.2')                     // returns number 7.2\n   *    math.number(true)                      // returns number 1\n   *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]\n   *    math.number(math.unit('52cm'), 'm')    // returns 0.52\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, index, matrix, string, unit\n   *\n   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted\n   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number\n   * @return {number | Array | Matrix} The created number\n   */\n\n  var number = typed('number', {\n    '': function _() {\n      return 0;\n    },\n    number: function number(x) {\n      return x;\n    },\n    string: function string(x) {\n      if (x === 'NaN') return NaN;\n      var nonDecimalNumberParts = getNonDecimalNumberParts(x);\n\n      if (nonDecimalNumberParts) {\n        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);\n      }\n\n      var size = 0;\n      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);\n\n      if (wordSizeSuffixMatch) {\n        // x includes a size suffix like 0xffffi32, so we extract\n        // the suffix and remove it from x\n        size = Number(wordSizeSuffixMatch[2]);\n        x = wordSizeSuffixMatch[1];\n      }\n\n      var num = Number(x);\n\n      if (isNaN(num)) {\n        throw new SyntaxError('String \"' + x + '\" is no valid number');\n      }\n\n      if (wordSizeSuffixMatch) {\n        // x is a signed bin, oct, or hex literal\n        // num is the value of string x if x is interpreted as unsigned\n        if (num > 2 ** size - 1) {\n          // literal is too large for size suffix\n          throw new SyntaxError(\"String \\\"\".concat(x, \"\\\" is out of range\"));\n        } // check if the bit at index size - 1 is set and if so do the twos complement\n\n\n        if (num >= 2 ** (size - 1)) {\n          num = num - 2 ** size;\n        }\n      }\n\n      return num;\n    },\n    BigNumber: function BigNumber(x) {\n      return x.toNumber();\n    },\n    Fraction: function Fraction(x) {\n      return x.valueOf();\n    },\n    Unit: typed.referToSelf(self => x => {\n      var clone = x.clone();\n      clone.value = self(x.value);\n      return clone;\n    }),\n    null: function _null(x) {\n      return 0;\n    },\n    'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {\n      return unit.toNumber(valuelessUnit);\n    },\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))\n  }); // reviver function to parse a JSON object like:\n  //\n  //     {\"mathjs\":\"number\",\"value\":\"2.3\"}\n  //\n  // into a number 2.3\n\n  number.fromJSON = function (json) {\n    return parseFloat(json.value);\n  };\n\n  return number;\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/type/number.js"],"names":["factory","deepMap","name","dependencies","getNonDecimalNumberParts","input","nonDecimalWithRadixMatch","match","radix","integerPart","fractionalPart","makeNumberFromNonDecimalParts","parts","n","parseInt","f","i","length","digitValue","Math","pow","result","isNaN","SyntaxError","createNumber","_ref","typed","number","_","x","string","NaN","nonDecimalNumberParts","size","wordSizeSuffixMatch","Number","num","concat","BigNumber","toNumber","Fraction","valueOf","Unit","referToSelf","self","clone","value","null","_null","UnitStringUnit","unit","valuelessUnit","fromJSON","json","parseFloat"],"mappings":"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","sourcesContent":["import { factory } from '../utils/factory.js';\nimport { deepMap } from '../utils/collection.js';\nvar name = 'number';\nvar dependencies = ['typed'];\n\n/**\n * Separates the radix, integer part, and fractional part of a non decimal number string\n * @param {string} input string to parse\n * @returns {object} the parts of the string or null if not a valid input\n */\nfunction getNonDecimalNumberParts(input) {\n  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\\.([0-9a-fA-F]*)/);\n  if (nonDecimalWithRadixMatch) {\n    var radix = {\n      '0b': 2,\n      '0o': 8,\n      '0x': 16\n    }[nonDecimalWithRadixMatch[1]];\n    var integerPart = nonDecimalWithRadixMatch[2];\n    var fractionalPart = nonDecimalWithRadixMatch[3];\n    return {\n      input,\n      radix,\n      integerPart,\n      fractionalPart\n    };\n  } else {\n    return null;\n  }\n}\n\n/**\n * Makes a number from a radix, and integer part, and a fractional part\n * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)\n * @returns {number} the number\n */\nfunction makeNumberFromNonDecimalParts(parts) {\n  var n = parseInt(parts.integerPart, parts.radix);\n  var f = 0;\n  for (var i = 0; i < parts.fractionalPart.length; i++) {\n    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);\n    f += digitValue / Math.pow(parts.radix, i + 1);\n  }\n  var result = n + f;\n  if (isNaN(result)) {\n    throw new SyntaxError('String \"' + parts.input + '\" is no valid number');\n  }\n  return result;\n}\nexport var createNumber = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Create a number or convert a string, boolean, or unit to a number.\n   * When value is a matrix, all elements will be converted to number.\n   *\n   * Syntax:\n   *\n   *    math.number(value)\n   *    math.number(unit, valuelessUnit)\n   *\n   * Examples:\n   *\n   *    math.number(2)                         // returns number 2\n   *    math.number('7.2')                     // returns number 7.2\n   *    math.number(true)                      // returns number 1\n   *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]\n   *    math.number(math.unit('52cm'), 'm')    // returns 0.52\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, index, matrix, string, unit\n   *\n   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted\n   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number\n   * @return {number | Array | Matrix} The created number\n   */\n  var number = typed('number', {\n    '': function _() {\n      return 0;\n    },\n    number: function number(x) {\n      return x;\n    },\n    string: function string(x) {\n      if (x === 'NaN') return NaN;\n      var nonDecimalNumberParts = getNonDecimalNumberParts(x);\n      if (nonDecimalNumberParts) {\n        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);\n      }\n      var size = 0;\n      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);\n      if (wordSizeSuffixMatch) {\n        // x includes a size suffix like 0xffffi32, so we extract\n        // the suffix and remove it from x\n        size = Number(wordSizeSuffixMatch[2]);\n        x = wordSizeSuffixMatch[1];\n      }\n      var num = Number(x);\n      if (isNaN(num)) {\n        throw new SyntaxError('String \"' + x + '\" is no valid number');\n      }\n      if (wordSizeSuffixMatch) {\n        // x is a signed bin, oct, or hex literal\n        // num is the value of string x if x is interpreted as unsigned\n        if (num > 2 ** size - 1) {\n          // literal is too large for size suffix\n          throw new SyntaxError(\"String \\\"\".concat(x, \"\\\" is out of range\"));\n        }\n        // check if the bit at index size - 1 is set and if so do the twos complement\n        if (num >= 2 ** (size - 1)) {\n          num = num - 2 ** size;\n        }\n      }\n      return num;\n    },\n    BigNumber: function BigNumber(x) {\n      return x.toNumber();\n    },\n    Fraction: function Fraction(x) {\n      return x.valueOf();\n    },\n    Unit: typed.referToSelf(self => x => {\n      var clone = x.clone();\n      clone.value = self(x.value);\n      return clone;\n    }),\n    null: function _null(x) {\n      return 0;\n    },\n    'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {\n      return unit.toNumber(valuelessUnit);\n    },\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))\n  });\n\n  // reviver function to parse a JSON object like:\n  //\n  //     {\"mathjs\":\"number\",\"value\":\"2.3\"}\n  //\n  // into a number 2.3\n  number.fromJSON = function (json) {\n    return parseFloat(json.value);\n  };\n  return number;\n});"]},"metadata":{},"sourceType":"module"}