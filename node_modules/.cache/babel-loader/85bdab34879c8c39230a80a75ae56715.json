{"ast":null,"code":"import { checkBroadcastingRules } from '../../../utils/array.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n\n\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n    // calculate the max dimensions\n\n\n    var sizeMax = [];\n\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    } // check if the broadcasting rules applyes for both matrices\n\n\n    checkBroadcastingRules(sizeA, sizeMax);\n    checkBroadcastingRules(sizeB, sizeMax); // reshape A or B if needed to make them ready for concat\n\n    var AA = A.clone();\n    var BB = B.clone();\n\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    } // stretches the matrices on each dimension to make them the same size\n\n\n    for (var _dim = 0; _dim < N; _dim++) {\n      if (AA._size[_dim] < sizeMax[_dim]) {\n        AA = _stretch(AA, sizeMax[_dim], _dim);\n      }\n\n      if (BB._size[_dim] < sizeMax[_dim]) {\n        BB = _stretch(BB, sizeMax[_dim], _dim);\n      }\n    } // return the array with the two broadcasted matrices\n\n\n    return [AA, BB];\n  };\n\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"],"names":["checkBroadcastingRules","factory","name","dependancies","createBroadcast","_ref","concat","A","B","N","Math","max","_size","length","every","dim","i","sizeA","_padLeft","sizeB","sizeMax","AA","clone","BB","reshape","_dim","_stretch","shape","filler","Array","fill","arrayToStretch","sizeToStretch","dimToStretch"],"mappings":"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","sourcesContent":["import { checkBroadcastingRules } from '../../../utils/array.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n\n    // calculate the max dimensions\n    var sizeMax = [];\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    }\n\n    // check if the broadcasting rules applyes for both matrices\n    checkBroadcastingRules(sizeA, sizeMax);\n    checkBroadcastingRules(sizeB, sizeMax);\n\n    // reshape A or B if needed to make them ready for concat\n    var AA = A.clone();\n    var BB = B.clone();\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    }\n\n    // stretches the matrices on each dimension to make them the same size\n    for (var _dim = 0; _dim < N; _dim++) {\n      if (AA._size[_dim] < sizeMax[_dim]) {\n        AA = _stretch(AA, sizeMax[_dim], _dim);\n      }\n      if (BB._size[_dim] < sizeMax[_dim]) {\n        BB = _stretch(BB, sizeMax[_dim], _dim);\n      }\n    }\n\n    // return the array with the two broadcasted matrices\n    return [AA, BB];\n  };\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n});"]},"metadata":{},"sourceType":"module"}