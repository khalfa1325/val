{"ast":null,"code":"import { isBigNumber, isCollection, isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { createApply } from '../matrix/apply.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n\n  var apply = createApply({\n    typed,\n    isInteger\n  });\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return typed(name, {\n    'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),\n    'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,\n    'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),\n    'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)\n  });\n\n  function _quantileSeqDim(data, prob, sorted, dim) {\n    // return [1.3, 1.2]\n    return apply(data, dim, x => quantileSeq(x, prob, sorted));\n  }\n\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n\n    if (isCollection(data)) {\n      sorted = sorted || false;\n\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n\n        if (isNumber(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!isInteger(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n\n            return probArr;\n          }\n        }\n\n        if (isBigNumber(probOrN)) {\n          var BigNumber = probOrN.constructor;\n\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          one = new BigNumber(1);\n\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n\n            var intN = probOrN.toNumber();\n\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n\n            var _nPlusOne = new BigNumber(intN + 1);\n\n            probArr = new Array(intN);\n\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n\n            return probArr;\n          }\n        }\n\n        if (isCollection(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          var probOrNArr = probOrN.valueOf();\n          probArr = new Array(probOrNArr.length);\n\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrNArr[_i2];\n\n            if (isNumber(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if (isBigNumber(currProb)) {\n              one = new currProb.constructor(1);\n\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n\n          return probArr;\n        }\n\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n\n    if (isNumber(prob)) {\n      var _index = prob * (len - 1);\n\n      var _fracPart = _index % 1;\n\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n\n      var _integerPart = Math.floor(_index);\n\n      var _left;\n\n      var _right;\n\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n\n    var index = prob.times(len - 1);\n\n    if (index.isInteger()) {\n      index = index.toNumber();\n\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n\n      validate(_value);\n      return _value;\n    }\n\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js"],"names":["isBigNumber","isCollection","isNumber","flatten","factory","createApply","name","dependencies","createQuantileSeq","_ref","typed","add","multiply","partitionSelect","compare","isInteger","apply","validate","numberBigNumberUnit","x","data","prob","quantileSeq","dim","_quantileSeqDim","sorted","probOrN","probArr","dataArr","one","arguments","length","SyntaxError","valueOf","Error","_quantileSeq","nPlusOne","Array","i","BigNumber","constructor","isNegative","lte","gt","intN","toNumber","_nPlusOne","_i","div","probOrNArr","_i2","currProb","TypeError","array","flat","len","_index","_fracPart","value","_integerPart","Math","floor","_left","_right","index","times","_value","integerPart","fracPart","minus","integerPartNumber","left","right","_i3"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,YAAtB,EAAoCC,QAApC,QAAoD,mBAApD;AACA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,WAAT,QAA4B,oBAA5B;AACA,IAAIC,IAAI,GAAG,aAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,KAAV,EAAiB,UAAjB,EAA6B,iBAA7B,EAAgD,SAAhD,EAA2D,WAA3D,CAAnB;AACA,OAAO,IAAIC,iBAAiB,GAAG,eAAeJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AAChF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,GAFE;AAGFC,IAAAA,QAHE;AAIFC,IAAAA,eAJE;AAKFC,IAAAA,OALE;AAMFC,IAAAA;AANE,MAOAN,IAPJ;AAQA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE,MAAIO,KAAK,GAAGX,WAAW,CAAC;AACtBK,IAAAA,KADsB;AAEtBK,IAAAA;AAFsB,GAAD,CAAvB;AAIA;AACF;AACA;AACA;AACA;AACA;;AACE,MAAIE,QAAQ,GAAGP,KAAK,CAAC;AACnB,iCAA6B,SAASQ,mBAAT,CAA6BC,CAA7B,EAAgC;AAC3D,aAAOA,CAAP;AACD;AAHkB,GAAD,CAApB;AAKA,SAAOT,KAAK,CAACJ,IAAD,EAAO;AACjB,4CAAwC,CAACc,IAAD,EAAOC,IAAP,KAAgBC,WAAW,CAACF,IAAD,EAAOC,IAAP,EAAa,KAAb,CADlD;AAEjB,qDAAiDC,WAFhC;AAGjB,oDAAgD,CAACF,IAAD,EAAOC,IAAP,EAAaE,GAAb,KAAqBC,eAAe,CAACJ,IAAD,EAAOC,IAAP,EAAa,KAAb,EAAoBE,GAApB,CAHnE;AAIjB,6DAAyD,CAACH,IAAD,EAAOC,IAAP,EAAaI,MAAb,EAAqBF,GAArB,KAA6BC,eAAe,CAACJ,IAAD,EAAOC,IAAP,EAAaI,MAAb,EAAqBF,GAArB;AAJpF,GAAP,CAAZ;;AAMA,WAASC,eAAT,CAAyBJ,IAAzB,EAA+BC,IAA/B,EAAqCI,MAArC,EAA6CF,GAA7C,EAAkD;AAChD;AACA,WAAOP,KAAK,CAACI,IAAD,EAAOG,GAAP,EAAYJ,CAAC,IAAIG,WAAW,CAACH,CAAD,EAAIE,IAAJ,EAAUI,MAAV,CAA5B,CAAZ;AACD;;AACD,WAASH,WAAT,CAAqBF,IAArB,EAA2BM,OAA3B,EAAoCD,MAApC,EAA4C;AAC1C,QAAIE,OAAJ,EAAaC,OAAb,EAAsBC,GAAtB;;AACA,QAAIC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAACC,MAAV,GAAmB,CAA/C,EAAkD;AAChD,YAAM,IAAIC,WAAJ,CAAgB,uDAAhB,CAAN;AACD;;AACD,QAAI/B,YAAY,CAACmB,IAAD,CAAhB,EAAwB;AACtBK,MAAAA,MAAM,GAAGA,MAAM,IAAI,KAAnB;;AACA,UAAI,OAAOA,MAAP,KAAkB,SAAtB,EAAiC;AAC/BG,QAAAA,OAAO,GAAGR,IAAI,CAACa,OAAL,EAAV;;AACA,YAAI/B,QAAQ,CAACwB,OAAD,CAAZ,EAAuB;AACrB,cAAIA,OAAO,GAAG,CAAd,EAAiB;AACf,kBAAM,IAAIQ,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,cAAIR,OAAO,IAAI,CAAf,EAAkB;AAChB;AACA,mBAAOS,YAAY,CAACP,OAAD,EAAUF,OAAV,EAAmBD,MAAnB,CAAnB;AACD;;AACD,cAAIC,OAAO,GAAG,CAAd,EAAiB;AACf;AACA,gBAAI,CAACX,SAAS,CAACW,OAAD,CAAd,EAAyB;AACvB,oBAAM,IAAIQ,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,gBAAIE,QAAQ,GAAGV,OAAO,GAAG,CAAzB;AACAC,YAAAA,OAAO,GAAG,IAAIU,KAAJ,CAAUX,OAAV,CAAV;;AACA,iBAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,OAApB,GAA8B;AAC5BC,cAAAA,OAAO,CAACW,CAAD,CAAP,GAAaH,YAAY,CAACP,OAAD,EAAU,EAAEU,CAAF,GAAMF,QAAhB,EAA0BX,MAA1B,CAAzB;AACD;;AACD,mBAAOE,OAAP;AACD;AACF;;AACD,YAAI3B,WAAW,CAAC0B,OAAD,CAAf,EAA0B;AACxB,cAAIa,SAAS,GAAGb,OAAO,CAACc,WAAxB;;AACA,cAAId,OAAO,CAACe,UAAR,EAAJ,EAA0B;AACxB,kBAAM,IAAIP,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACDL,UAAAA,GAAG,GAAG,IAAIU,SAAJ,CAAc,CAAd,CAAN;;AACA,cAAIb,OAAO,CAACgB,GAAR,CAAYb,GAAZ,CAAJ,EAAsB;AACpB;AACA,mBAAO,IAAIU,SAAJ,CAAcJ,YAAY,CAACP,OAAD,EAAUF,OAAV,EAAmBD,MAAnB,CAA1B,CAAP;AACD;;AACD,cAAIC,OAAO,CAACiB,EAAR,CAAWd,GAAX,CAAJ,EAAqB;AACnB;AACA,gBAAI,CAACH,OAAO,CAACX,SAAR,EAAL,EAA0B;AACxB,oBAAM,IAAImB,KAAJ,CAAU,8BAAV,CAAN;AACD,aAJkB,CAMnB;AACA;;;AACA,gBAAIU,IAAI,GAAGlB,OAAO,CAACmB,QAAR,EAAX;;AACA,gBAAID,IAAI,GAAG,UAAX,EAAuB;AACrB,oBAAM,IAAIV,KAAJ,CAAU,mFAAV,CAAN;AACD;;AACD,gBAAIY,SAAS,GAAG,IAAIP,SAAJ,CAAcK,IAAI,GAAG,CAArB,CAAhB;;AACAjB,YAAAA,OAAO,GAAG,IAAIU,KAAJ,CAAUO,IAAV,CAAV;;AACA,iBAAK,IAAIG,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,IAAtB,GAA6B;AAC3BjB,cAAAA,OAAO,CAACoB,EAAD,CAAP,GAAc,IAAIR,SAAJ,CAAcJ,YAAY,CAACP,OAAD,EAAU,IAAIW,SAAJ,CAAc,EAAEQ,EAAhB,EAAoBC,GAApB,CAAwBF,SAAxB,CAAV,EAA8CrB,MAA9C,CAA1B,CAAd;AACD;;AACD,mBAAOE,OAAP;AACD;AACF;;AACD,YAAI1B,YAAY,CAACyB,OAAD,CAAhB,EAA2B;AACzB;AACA,cAAIuB,UAAU,GAAGvB,OAAO,CAACO,OAAR,EAAjB;AACAN,UAAAA,OAAO,GAAG,IAAIU,KAAJ,CAAUY,UAAU,CAAClB,MAArB,CAAV;;AACA,eAAK,IAAImB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGvB,OAAO,CAACI,MAAhC,EAAwC,EAAEmB,GAA1C,EAA+C;AAC7C,gBAAIC,QAAQ,GAAGF,UAAU,CAACC,GAAD,CAAzB;;AACA,gBAAIhD,QAAQ,CAACiD,QAAD,CAAZ,EAAwB;AACtB,kBAAIA,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAG,CAA/B,EAAkC;AAChC,sBAAM,IAAIjB,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,aAJD,MAIO,IAAIlC,WAAW,CAACmD,QAAD,CAAf,EAA2B;AAChCtB,cAAAA,GAAG,GAAG,IAAIsB,QAAQ,CAACX,WAAb,CAAyB,CAAzB,CAAN;;AACA,kBAAIW,QAAQ,CAACV,UAAT,MAAyBU,QAAQ,CAACR,EAAT,CAAYd,GAAZ,CAA7B,EAA+C;AAC7C,sBAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,aALM,MAKA;AACL,oBAAM,IAAIkB,SAAJ,CAAc,qDAAd,CAAN,CADK,CACuE;AAC7E;;AAEDzB,YAAAA,OAAO,CAACuB,GAAD,CAAP,GAAef,YAAY,CAACP,OAAD,EAAUuB,QAAV,EAAoB1B,MAApB,CAA3B;AACD;;AACD,iBAAOE,OAAP;AACD;;AACD,cAAM,IAAIyB,SAAJ,CAAc,qDAAd,CAAN,CA5E+B,CA4E6C;AAC7E;;AAED,YAAM,IAAIA,SAAJ,CAAc,qDAAd,CAAN,CAjFsB,CAiFsD;AAC7E;;AAED,UAAM,IAAIA,SAAJ,CAAc,qDAAd,CAAN,CAzF0C,CAyFkC;AAC7E;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASjB,YAAT,CAAsBkB,KAAtB,EAA6BhC,IAA7B,EAAmCI,MAAnC,EAA2C;AACzC,QAAI6B,IAAI,GAAGnD,OAAO,CAACkD,KAAD,CAAlB;AACA,QAAIE,GAAG,GAAGD,IAAI,CAACvB,MAAf;;AACA,QAAIwB,GAAG,KAAK,CAAZ,EAAe;AACb,YAAM,IAAIrB,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,QAAIhC,QAAQ,CAACmB,IAAD,CAAZ,EAAoB;AAClB,UAAImC,MAAM,GAAGnC,IAAI,IAAIkC,GAAG,GAAG,CAAV,CAAjB;;AACA,UAAIE,SAAS,GAAGD,MAAM,GAAG,CAAzB;;AACA,UAAIC,SAAS,KAAK,CAAlB,EAAqB;AACnB,YAAIC,KAAK,GAAGjC,MAAM,GAAG6B,IAAI,CAACE,MAAD,CAAP,GAAkB3C,eAAe,CAACyC,IAAD,EAAOE,MAAP,CAAnD;AACAvC,QAAAA,QAAQ,CAACyC,KAAD,CAAR;AACA,eAAOA,KAAP;AACD;;AACD,UAAIC,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWL,MAAX,CAAnB;;AACA,UAAIM,KAAJ;;AACA,UAAIC,MAAJ;;AACA,UAAItC,MAAJ,EAAY;AACVqC,QAAAA,KAAK,GAAGR,IAAI,CAACK,YAAD,CAAZ;AACAI,QAAAA,MAAM,GAAGT,IAAI,CAACK,YAAY,GAAG,CAAhB,CAAb;AACD,OAHD,MAGO;AACLI,QAAAA,MAAM,GAAGlD,eAAe,CAACyC,IAAD,EAAOK,YAAY,GAAG,CAAtB,CAAxB,CADK,CAGL;;AACAG,QAAAA,KAAK,GAAGR,IAAI,CAACK,YAAD,CAAZ;;AACA,aAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,YAApB,EAAkC,EAAErB,CAApC,EAAuC;AACrC,cAAIxB,OAAO,CAACwC,IAAI,CAAChB,CAAD,CAAL,EAAUwB,KAAV,CAAP,GAA0B,CAA9B,EAAiC;AAC/BA,YAAAA,KAAK,GAAGR,IAAI,CAAChB,CAAD,CAAZ;AACD;AACF;AACF;;AACDrB,MAAAA,QAAQ,CAAC6C,KAAD,CAAR;AACA7C,MAAAA,QAAQ,CAAC8C,MAAD,CAAR,CA1BkB,CA4BlB;;AACA,aAAOpD,GAAG,CAACC,QAAQ,CAACkD,KAAD,EAAQ,IAAIL,SAAZ,CAAT,EAAiC7C,QAAQ,CAACmD,MAAD,EAASN,SAAT,CAAzC,CAAV;AACD,KApCwC,CAsCzC;;;AACA,QAAIO,KAAK,GAAG3C,IAAI,CAAC4C,KAAL,CAAWV,GAAG,GAAG,CAAjB,CAAZ;;AACA,QAAIS,KAAK,CAACjD,SAAN,EAAJ,EAAuB;AACrBiD,MAAAA,KAAK,GAAGA,KAAK,CAACnB,QAAN,EAAR;;AACA,UAAIqB,MAAM,GAAGzC,MAAM,GAAG6B,IAAI,CAACU,KAAD,CAAP,GAAiBnD,eAAe,CAACyC,IAAD,EAAOU,KAAP,CAAnD;;AACA/C,MAAAA,QAAQ,CAACiD,MAAD,CAAR;AACA,aAAOA,MAAP;AACD;;AACD,QAAIC,WAAW,GAAGH,KAAK,CAACH,KAAN,EAAlB;AACA,QAAIO,QAAQ,GAAGJ,KAAK,CAACK,KAAN,CAAYF,WAAZ,CAAf;AACA,QAAIG,iBAAiB,GAAGH,WAAW,CAACtB,QAAZ,EAAxB;AACA,QAAI0B,IAAJ;AACA,QAAIC,KAAJ;;AACA,QAAI/C,MAAJ,EAAY;AACV8C,MAAAA,IAAI,GAAGjB,IAAI,CAACgB,iBAAD,CAAX;AACAE,MAAAA,KAAK,GAAGlB,IAAI,CAACgB,iBAAiB,GAAG,CAArB,CAAZ;AACD,KAHD,MAGO;AACLE,MAAAA,KAAK,GAAG3D,eAAe,CAACyC,IAAD,EAAOgB,iBAAiB,GAAG,CAA3B,CAAvB,CADK,CAGL;;AACAC,MAAAA,IAAI,GAAGjB,IAAI,CAACgB,iBAAD,CAAX;;AACA,WAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,iBAAxB,EAA2C,EAAEG,GAA7C,EAAkD;AAChD,YAAI3D,OAAO,CAACwC,IAAI,CAACmB,GAAD,CAAL,EAAYF,IAAZ,CAAP,GAA2B,CAA/B,EAAkC;AAChCA,UAAAA,IAAI,GAAGjB,IAAI,CAACmB,GAAD,CAAX;AACD;AACF;AACF;;AACDxD,IAAAA,QAAQ,CAACsD,IAAD,CAAR;AACAtD,IAAAA,QAAQ,CAACuD,KAAD,CAAR,CAlEyC,CAoEzC;;AACA,QAAI3C,GAAG,GAAG,IAAIuC,QAAQ,CAAC5B,WAAb,CAAyB,CAAzB,CAAV;AACA,WAAO7B,GAAG,CAACC,QAAQ,CAAC2D,IAAD,EAAO1C,GAAG,CAACwC,KAAJ,CAAUD,QAAV,CAAP,CAAT,EAAsCxD,QAAQ,CAAC4D,KAAD,EAAQJ,QAAR,CAA9C,CAAV;AACD;AACF,CAlPoD,CAA9C","sourcesContent":["import { isBigNumber, isCollection, isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { createApply } from '../matrix/apply.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n\n  var apply = createApply({\n    typed,\n    isInteger\n  });\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return typed(name, {\n    'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),\n    'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,\n    'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),\n    'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)\n  });\n  function _quantileSeqDim(data, prob, sorted, dim) {\n    // return [1.3, 1.2]\n    return apply(data, dim, x => quantileSeq(x, prob, sorted));\n  }\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n    if (isCollection(data)) {\n      sorted = sorted || false;\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n        if (isNumber(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!isInteger(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n            return probArr;\n          }\n        }\n        if (isBigNumber(probOrN)) {\n          var BigNumber = probOrN.constructor;\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n          one = new BigNumber(1);\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            }\n\n            // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n            var intN = probOrN.toNumber();\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n            var _nPlusOne = new BigNumber(intN + 1);\n            probArr = new Array(intN);\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n            return probArr;\n          }\n        }\n        if (isCollection(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          var probOrNArr = probOrN.valueOf();\n          probArr = new Array(probOrNArr.length);\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrNArr[_i2];\n            if (isNumber(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if (isBigNumber(currProb)) {\n              one = new currProb.constructor(1);\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n          return probArr;\n        }\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    if (isNumber(prob)) {\n      var _index = prob * (len - 1);\n      var _fracPart = _index % 1;\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n      var _integerPart = Math.floor(_index);\n      var _left;\n      var _right;\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1);\n\n        // max of partition is kth largest\n        _left = flat[_integerPart];\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n      validate(_left);\n      validate(_right);\n\n      // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    }\n\n    // If prob is a BigNumber\n    var index = prob.times(len - 1);\n    if (index.isInteger()) {\n      index = index.toNumber();\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n      validate(_value);\n      return _value;\n    }\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1);\n\n      // max of partition is kth largest\n      left = flat[integerPartNumber];\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n    validate(left);\n    validate(right);\n\n    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n});"]},"metadata":{},"sourceType":"module"}