{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super(); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n\n      this.end = end; // included upper-bound\n\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isRangeNode() {\n      return true;\n    }\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n\n\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var range = math.range;\n\n      var evalStart = this.start._compile(math, argNames);\n\n      var evalEnd = this.end._compile(math, argNames);\n\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n\n\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toString(options);\n\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toString(options);\n\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toString(options);\n\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n\n      str += ':' + end;\n      return str;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n\n\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toHTML(options);\n\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toHTML(options);\n\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n\n      var end = this.end.toHTML(options);\n\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n\n      if (this.step) {\n        var step = this.step.toTex(options);\n\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toTex(options);\n\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n\n      str += ':' + end;\n      return str;\n    }\n\n  }\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","constructor","TypeError","arguments","length","Error","type","isRangeNode","needsEnd","endSymbols","filter","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super();\n      // validate inputs\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n      this.end = end; // included upper-bound\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n    get isRangeNode() {\n      return true;\n    }\n\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var range = math.range;\n      var evalStart = this.start._compile(math, argNames);\n      var evalEnd = this.end._compile(math, argNames);\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toString(options);\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toString(options);\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toString(options);\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n      str += ':' + end;\n      return str;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toHTML(options);\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toHTML(options);\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n      var end = this.end.toHTML(options);\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n      if (this.step) {\n        var step = this.step.toTex(options);\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toTex(options);\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n      str += ':' + end;\n      return str;\n    }\n  }\n  _defineProperty(RangeNode, \"name\", name);\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}