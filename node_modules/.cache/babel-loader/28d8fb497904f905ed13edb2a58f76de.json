{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    mathWithTransform\n  } = _ref;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n  function _validateScope(scope) {\n    for (var symbol of [...keywords]) {\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n\n  class Node {\n    get type() {\n      return 'Node';\n    }\n\n    get isNode() {\n      return true;\n    }\n    /**\n     * Evaluate the node\n     * @param {Object} [scope]  Scope to read/write variables\n     * @return {*}              Returns the result\n     */\n\n\n    evaluate(scope) {\n      return this.compile().evaluate(scope);\n    }\n    /**\n     * Compile the node into an optimized, evauatable JavaScript function\n     * @return {{evaluate: function([Object])}} object\n     *                Returns an object with a function 'evaluate',\n     *                which can be invoked as expr.evaluate([scope: Object]),\n     *                where scope is an optional object with\n     *                variables.\n     */\n\n\n    compile() {\n      var expr = this._compile(mathWithTransform, {});\n\n      var args = {};\n      var context = null;\n\n      function evaluate(scope) {\n        var s = createMap(scope);\n\n        _validateScope(s);\n\n        return expr(s, args, context);\n      }\n\n      return {\n        evaluate\n      };\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      throw new Error('Method _compile must be implemented by type ' + this.type);\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run forEach on a Node interface');\n    }\n    /**\n     * Create a new Node whose children are the results of calling the\n     * provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run map on a Node interface');\n    }\n    /**\n     * Validate whether an object is a Node, for use with map\n     * @param {Node} node\n     * @returns {Node} Returns the input if it's a node, else throws an Error\n     * @protected\n     */\n\n\n    _ifNode(node) {\n      if (!isNode(node)) {\n        throw new TypeError('Callback function must return a Node');\n      }\n\n      return node;\n    }\n    /**\n     * Recursively traverse all nodes in a node tree. Executes given callback for\n     * this node and each of its child nodes.\n     * @param {function(node: Node, path: string, parent: Node)} callback\n     *          A callback called for every node in the node tree.\n     */\n\n\n    traverse(callback) {\n      // execute callback for itself\n      // eslint-disable-next-line\n      callback(this, null, null); // recursively traverse over all children of a node\n\n      function _traverse(node, callback) {\n        node.forEach(function (child, path, parent) {\n          callback(child, path, parent);\n\n          _traverse(child, callback);\n        });\n      }\n\n      _traverse(this, callback);\n    }\n    /**\n     * Recursively transform a node tree via a transform function.\n     *\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\n     * a ConstantNode with value 2:\n     *\n     *     const res = Node.transform(function (node, path, parent) {\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n     *         return new ConstantNode(2)\n     *       }\n     *       else {\n     *         return node\n     *       }\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *          A mapping function accepting a node, and returning\n     *          a replacement for the node or the original node. The \"signature\"\n     *          of the callback must be:\n     *          callback(node: Node, index: string, parent: Node) : Node\n     * @return {Node} Returns the original node or its replacement\n     */\n\n\n    transform(callback) {\n      function _transform(child, path, parent) {\n        var replacement = callback(child, path, parent);\n\n        if (replacement !== child) {\n          // stop iterating when the node is replaced\n          return replacement;\n        }\n\n        return child.map(_transform);\n      }\n\n      return _transform(this, null, null);\n    }\n    /**\n     * Find any node in the node tree matching given filter function. For\n     * example, to find all nodes of type SymbolNode having name 'x':\n     *\n     *     const results = Node.filter(function (node) {\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *            A test function returning true when a node matches, and false\n     *            otherwise. Function signature:\n     *            callback(node: Node, index: string, parent: Node) : boolean\n     * @return {Node[]} nodes\n     *            An array with nodes matching given filter criteria\n     */\n\n\n    filter(callback) {\n      var nodes = [];\n      this.traverse(function (node, path, parent) {\n        if (callback(node, path, parent)) {\n          nodes.push(node);\n        }\n      });\n      return nodes;\n    }\n    /**\n     * Create a shallow clone of this node\n     * @return {Node}\n     */\n\n\n    clone() {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot clone a Node interface');\n    }\n    /**\n     * Create a deep clone of this node\n     * @return {Node}\n     */\n\n\n    cloneDeep() {\n      return this.map(function (node) {\n        return node.cloneDeep();\n      });\n    }\n    /**\n     * Deep compare this node with another node.\n     * @param {Node} other\n     * @return {boolean} Returns true when both nodes are of the same type and\n     *                   contain the same values (as do their childs)\n     */\n\n\n    equals(other) {\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n    }\n    /**\n     * Get string representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n\n\n    toString(options) {\n      var customString = this._getCustomString(options);\n\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n\n      return this._toString(options);\n    }\n    /**\n     * Get a JSON representation of the node\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n     * implementations of Node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n    }\n    /**\n     * Get HTML representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\" or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n\n\n    toHTML(options) {\n      var customString = this._getCustomString(options);\n\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n\n      return this.toHTML(options);\n    }\n    /**\n     * Internal function to generate the string output.\n     * This has to be implemented by every Node\n     *\n     * @throws {Error}\n     */\n\n\n    _toString() {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toString not implemented for ' + this.type);\n    }\n    /**\n     * Get LaTeX representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n\n\n    toTex(options) {\n      var customString = this._getCustomString(options);\n\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n\n      return this._toTex(options);\n    }\n    /**\n     * Internal function to generate the LaTeX output.\n     * This has to be implemented by every Node\n     *\n     * @param {Object} [options]\n     * @throws {Error}\n     */\n\n\n    _toTex(options) {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toTex not implemented for ' + this.type);\n    }\n    /**\n     * Helper used by `to...` functions.\n     */\n\n\n    _getCustomString(options) {\n      if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            return;\n\n          case 'function':\n            return options.handler(this, options);\n\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n      }\n    }\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n\n\n    getIdentifier() {\n      return this.type;\n    }\n    /**\n     * Get the content of the current Node.\n     * @return {Node} node\n     **/\n\n\n    getContent() {\n      return this;\n    }\n\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/expression/node/Node.js"],"names":["isNode","keywords","deepStrictEqual","factory","createMap","name","dependencies","createNode","_ref","mathWithTransform","_validateScope","scope","symbol","has","Error","Node","type","evaluate","compile","expr","_compile","args","context","s","math","argNames","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","_getCustomString","_toString","toJSON","toHTML","toTex","_toTex","handler","getIdentifier","getContent","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    mathWithTransform\n  } = _ref;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var symbol of [...keywords]) {\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  class Node {\n    get type() {\n      return 'Node';\n    }\n    get isNode() {\n      return true;\n    }\n\n    /**\n     * Evaluate the node\n     * @param {Object} [scope]  Scope to read/write variables\n     * @return {*}              Returns the result\n     */\n    evaluate(scope) {\n      return this.compile().evaluate(scope);\n    }\n\n    /**\n     * Compile the node into an optimized, evauatable JavaScript function\n     * @return {{evaluate: function([Object])}} object\n     *                Returns an object with a function 'evaluate',\n     *                which can be invoked as expr.evaluate([scope: Object]),\n     *                where scope is an optional object with\n     *                variables.\n     */\n    compile() {\n      var expr = this._compile(mathWithTransform, {});\n      var args = {};\n      var context = null;\n      function evaluate(scope) {\n        var s = createMap(scope);\n        _validateScope(s);\n        return expr(s, args, context);\n      }\n      return {\n        evaluate\n      };\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      throw new Error('Method _compile must be implemented by type ' + this.type);\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run forEach on a Node interface');\n    }\n\n    /**\n     * Create a new Node whose children are the results of calling the\n     * provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run map on a Node interface');\n    }\n\n    /**\n     * Validate whether an object is a Node, for use with map\n     * @param {Node} node\n     * @returns {Node} Returns the input if it's a node, else throws an Error\n     * @protected\n     */\n    _ifNode(node) {\n      if (!isNode(node)) {\n        throw new TypeError('Callback function must return a Node');\n      }\n      return node;\n    }\n\n    /**\n     * Recursively traverse all nodes in a node tree. Executes given callback for\n     * this node and each of its child nodes.\n     * @param {function(node: Node, path: string, parent: Node)} callback\n     *          A callback called for every node in the node tree.\n     */\n    traverse(callback) {\n      // execute callback for itself\n      // eslint-disable-next-line\n      callback(this, null, null);\n\n      // recursively traverse over all children of a node\n      function _traverse(node, callback) {\n        node.forEach(function (child, path, parent) {\n          callback(child, path, parent);\n          _traverse(child, callback);\n        });\n      }\n      _traverse(this, callback);\n    }\n\n    /**\n     * Recursively transform a node tree via a transform function.\n     *\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\n     * a ConstantNode with value 2:\n     *\n     *     const res = Node.transform(function (node, path, parent) {\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n     *         return new ConstantNode(2)\n     *       }\n     *       else {\n     *         return node\n     *       }\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *          A mapping function accepting a node, and returning\n     *          a replacement for the node or the original node. The \"signature\"\n     *          of the callback must be:\n     *          callback(node: Node, index: string, parent: Node) : Node\n     * @return {Node} Returns the original node or its replacement\n     */\n    transform(callback) {\n      function _transform(child, path, parent) {\n        var replacement = callback(child, path, parent);\n        if (replacement !== child) {\n          // stop iterating when the node is replaced\n          return replacement;\n        }\n        return child.map(_transform);\n      }\n      return _transform(this, null, null);\n    }\n\n    /**\n     * Find any node in the node tree matching given filter function. For\n     * example, to find all nodes of type SymbolNode having name 'x':\n     *\n     *     const results = Node.filter(function (node) {\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *            A test function returning true when a node matches, and false\n     *            otherwise. Function signature:\n     *            callback(node: Node, index: string, parent: Node) : boolean\n     * @return {Node[]} nodes\n     *            An array with nodes matching given filter criteria\n     */\n    filter(callback) {\n      var nodes = [];\n      this.traverse(function (node, path, parent) {\n        if (callback(node, path, parent)) {\n          nodes.push(node);\n        }\n      });\n      return nodes;\n    }\n\n    /**\n     * Create a shallow clone of this node\n     * @return {Node}\n     */\n    clone() {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot clone a Node interface');\n    }\n\n    /**\n     * Create a deep clone of this node\n     * @return {Node}\n     */\n    cloneDeep() {\n      return this.map(function (node) {\n        return node.cloneDeep();\n      });\n    }\n\n    /**\n     * Deep compare this node with another node.\n     * @param {Node} other\n     * @return {boolean} Returns true when both nodes are of the same type and\n     *                   contain the same values (as do their childs)\n     */\n    equals(other) {\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n    }\n\n    /**\n     * Get string representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toString(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toString(options);\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n     * implementations of Node\n     * @returns {Object}\n     */\n    toJSON() {\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n    }\n\n    /**\n     * Get HTML representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\" or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toHTML(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this.toHTML(options);\n    }\n\n    /**\n     * Internal function to generate the string output.\n     * This has to be implemented by every Node\n     *\n     * @throws {Error}\n     */\n    _toString() {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toString not implemented for ' + this.type);\n    }\n\n    /**\n     * Get LaTeX representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toTex(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toTex(options);\n    }\n\n    /**\n     * Internal function to generate the LaTeX output.\n     * This has to be implemented by every Node\n     *\n     * @param {Object} [options]\n     * @throws {Error}\n     */\n    _toTex(options) {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toTex not implemented for ' + this.type);\n    }\n\n    /**\n     * Helper used by `to...` functions.\n     */\n    _getCustomString(options) {\n      if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            return;\n          case 'function':\n            return options.handler(this, options);\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n      }\n    }\n\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n    getIdentifier() {\n      return this.type;\n    }\n\n    /**\n     * Get the content of the current Node.\n     * @return {Node} node\n     **/\n    getContent() {\n      return this;\n    }\n  }\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}