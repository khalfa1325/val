{"ast":null,"code":"import { isArray, isBigNumber, isMatrix, isNumber, isRange } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'index';\nvar dependencies = ['Index', 'getMatrixDataType'];\nexport var createIndexTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Index,\n    getMatrixDataType\n  } = _ref;\n  /**\n   * Attach a transform function to math.index\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n\n  return function indexTransform() {\n    var args = [];\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i]; // change from one-based to zero based, convert BigNumber to number and leave Array of Booleans as is\n\n      if (isRange(arg)) {\n        arg.start--;\n        arg.end -= arg.step > 0 ? 0 : 2;\n      } else if (arg && arg.isSet === true) {\n        arg = arg.map(function (v) {\n          return v - 1;\n        });\n      } else if (isArray(arg) || isMatrix(arg)) {\n        if (getMatrixDataType(arg) !== 'boolean') {\n          arg = arg.map(function (v) {\n            return v - 1;\n          });\n        }\n      } else if (isNumber(arg)) {\n        arg--;\n      } else if (isBigNumber(arg)) {\n        arg = arg.toNumber() - 1;\n      } else if (typeof arg === 'string') {// leave as is\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      }\n\n      args[i] = arg;\n    }\n\n    var res = new Index();\n    Index.apply(res, args);\n    return res;\n  };\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/expression/transform/index.transform.js"],"names":["isArray","isBigNumber","isMatrix","isNumber","isRange","factory","name","dependencies","createIndexTransform","_ref","Index","getMatrixDataType","indexTransform","args","i","ii","arguments","length","arg","start","end","step","isSet","map","v","toNumber","TypeError","res","apply","isTransformFunction"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,WAAlB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmDC,OAAnD,QAAkE,mBAAlE;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,OAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,mBAAV,CAAnB;AACA,OAAO,IAAIC,oBAAoB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AACnF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA;AAFE,MAGAF,IAHJ;AAIA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAO,SAASG,cAAT,GAA0B;AAC/B,QAAIC,IAAI,GAAG,EAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGC,SAAS,CAACC,MAA/B,EAAuCH,CAAC,GAAGC,EAA3C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,UAAII,GAAG,GAAGF,SAAS,CAACF,CAAD,CAAnB,CADkD,CAGlD;;AACA,UAAIV,OAAO,CAACc,GAAD,CAAX,EAAkB;AAChBA,QAAAA,GAAG,CAACC,KAAJ;AACAD,QAAAA,GAAG,CAACE,GAAJ,IAAWF,GAAG,CAACG,IAAJ,GAAW,CAAX,GAAe,CAAf,GAAmB,CAA9B;AACD,OAHD,MAGO,IAAIH,GAAG,IAAIA,GAAG,CAACI,KAAJ,KAAc,IAAzB,EAA+B;AACpCJ,QAAAA,GAAG,GAAGA,GAAG,CAACK,GAAJ,CAAQ,UAAUC,CAAV,EAAa;AACzB,iBAAOA,CAAC,GAAG,CAAX;AACD,SAFK,CAAN;AAGD,OAJM,MAIA,IAAIxB,OAAO,CAACkB,GAAD,CAAP,IAAgBhB,QAAQ,CAACgB,GAAD,CAA5B,EAAmC;AACxC,YAAIP,iBAAiB,CAACO,GAAD,CAAjB,KAA2B,SAA/B,EAA0C;AACxCA,UAAAA,GAAG,GAAGA,GAAG,CAACK,GAAJ,CAAQ,UAAUC,CAAV,EAAa;AACzB,mBAAOA,CAAC,GAAG,CAAX;AACD,WAFK,CAAN;AAGD;AACF,OANM,MAMA,IAAIrB,QAAQ,CAACe,GAAD,CAAZ,EAAmB;AACxBA,QAAAA,GAAG;AACJ,OAFM,MAEA,IAAIjB,WAAW,CAACiB,GAAD,CAAf,EAAsB;AAC3BA,QAAAA,GAAG,GAAGA,GAAG,CAACO,QAAJ,KAAiB,CAAvB;AACD,OAFM,MAEA,IAAI,OAAOP,GAAP,KAAe,QAAnB,EAA6B,CAClC;AACD,OAFM,MAEA;AACL,cAAM,IAAIQ,SAAJ,CAAc,8DAAd,CAAN;AACD;;AACDb,MAAAA,IAAI,CAACC,CAAD,CAAJ,GAAUI,GAAV;AACD;;AACD,QAAIS,GAAG,GAAG,IAAIjB,KAAJ,EAAV;AACAA,IAAAA,KAAK,CAACkB,KAAN,CAAYD,GAAZ,EAAiBd,IAAjB;AACA,WAAOc,GAAP;AACD,GAjCD;AAkCD,CA7CuD,EA6CrD;AACDE,EAAAA,mBAAmB,EAAE;AADpB,CA7CqD,CAAjD","sourcesContent":["import { isArray, isBigNumber, isMatrix, isNumber, isRange } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'index';\nvar dependencies = ['Index', 'getMatrixDataType'];\nexport var createIndexTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Index,\n    getMatrixDataType\n  } = _ref;\n  /**\n   * Attach a transform function to math.index\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  return function indexTransform() {\n    var args = [];\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n\n      // change from one-based to zero based, convert BigNumber to number and leave Array of Booleans as is\n      if (isRange(arg)) {\n        arg.start--;\n        arg.end -= arg.step > 0 ? 0 : 2;\n      } else if (arg && arg.isSet === true) {\n        arg = arg.map(function (v) {\n          return v - 1;\n        });\n      } else if (isArray(arg) || isMatrix(arg)) {\n        if (getMatrixDataType(arg) !== 'boolean') {\n          arg = arg.map(function (v) {\n            return v - 1;\n          });\n        }\n      } else if (isNumber(arg)) {\n        arg--;\n      } else if (isBigNumber(arg)) {\n        arg = arg.toNumber() - 1;\n      } else if (typeof arg === 'string') {\n        // leave as is\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      }\n      args[i] = arg;\n    }\n    var res = new Index();\n    Index.apply(res, args);\n    return res;\n  };\n}, {\n  isTransformFunction: true\n});"]},"metadata":{},"sourceType":"module"}