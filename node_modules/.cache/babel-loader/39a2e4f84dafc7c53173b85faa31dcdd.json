{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          }\n\n          if (size[0] === 0) {\n            return 1; // det of an empty matrix is per definition 1\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two-dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            }\n\n            if (cols === 0) {\n              return 1; // det of an empty matrix is per definition 1\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/function/matrix/det.js"],"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","divideScalar","isZero","unaryMinus","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","negated","rowIndices","fill","map","_","i","k","k_","_k","piv","piv_","i_","j"],"mappings":"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","sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          }\n          if (size[0] === 0) {\n            return 1; // det of an empty matrix is per definition 1\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // two-dimensional array\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            }\n            if (cols === 0) {\n              return 1; // det of an empty matrix is per definition 1\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}