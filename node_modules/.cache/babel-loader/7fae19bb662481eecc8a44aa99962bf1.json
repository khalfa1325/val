{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { isUnit, isNumber, isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'solveODE';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'max', 'map', 'abs', 'isPositive', 'isNegative', 'larger', 'smaller', 'matrix', 'bignumber', 'unaryMinus'];\nexport var createSolveODE = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    subtract,\n    multiply,\n    divide,\n    max,\n    map,\n    abs,\n    isPositive,\n    isNegative,\n    larger,\n    smaller,\n    matrix,\n    bignumber,\n    unaryMinus\n  } = _ref;\n  /**\n     * Numerical Integration of Ordinary Differential Equations\n     *\n     * Two variable step methods are provided:\n     * - \"RK23\": Bogacki–Shampine method\n     * - \"RK45\": Dormand-Prince method RK5(4)7M (default)\n     *\n     * The arguments are expected as follows.\n     *\n     * - `func` should be the forcing function `f(t, y)`\n     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`\n     * - `y0` the initial state values, should be a scalar or a flat array\n     * - `options` should be an object with the following information:\n     *   - `method` ('RK45'): ['RK23', 'RK45']\n     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value\n     *   - `firstStep`: Initial step size\n     *   - `minStep`: minimum step size of the method\n     *   - `maxStep`: maximum step size of the method\n     *   - `minDelta` (0.2): minimum ratio of change for the step\n     *   - `maxDelta` (5): maximum ratio of change for the step\n     *   - `maxIter` (1e4): maximum number of iterations\n     *\n     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:\n     * - `t` an array of size `[n]`\n     * - `y` the states array can be in two ways\n     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`\n     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`\n     *\n     * Syntax:\n     *\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, y0, options)\n     *\n     * Examples:\n     *\n     *     function func(t, y) {return y}\n     *     const tspan = [0, 4]\n     *     const y0 = 1\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, [1, 2])\n     *     math.solveODE(func, tspan, y0, { method:\"RK23\", maxStep:0.1 })\n     *\n     * See also:\n     *\n     *     derivative, simplifyCore\n     *\n     * @param {function} func The forcing function f(t,y)\n     * @param {Array | Matrix} tspan The time span\n     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value\n     * @param {Object} [options] Optional configuration options\n     * @return {Object} Return an object with t and y values as arrays\n     */\n\n  function _rk(butcherTableau) {\n    // generates an adaptive runge kutta method from it's butcher tableau\n    return function (f, tspan, y0, options) {\n      // adaptive runge kutta methods\n      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));\n\n      if (wrongTSpan) {\n        throw new Error('\"tspan\" must be an Array of two numeric values or two units [tStart, tEnd]');\n      }\n\n      var t0 = tspan[0]; // initial time\n\n      var tf = tspan[1]; // final time\n\n      var isForwards = larger(tf, t0);\n      var firstStep = options.firstStep;\n\n      if (firstStep !== undefined && !isPositive(firstStep)) {\n        throw new Error('\"firstStep\" must be positive');\n      }\n\n      var maxStep = options.maxStep;\n\n      if (maxStep !== undefined && !isPositive(maxStep)) {\n        throw new Error('\"maxStep\" must be positive');\n      }\n\n      var minStep = options.minStep;\n\n      if (minStep && isNegative(minStep)) {\n        throw new Error('\"minStep\" must be positive or zero');\n      }\n\n      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(x => x !== undefined);\n\n      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {\n        throw new Error('Inconsistent type of \"t\" dependant variables');\n      }\n\n      var steps = 1; // divide time in this number of steps\n\n      var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)\n\n      var minDelta = options.minDelta ? options.minDelta : 0.2;\n      var maxDelta = options.maxDelta ? options.maxDelta : 5;\n      var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong\n\n      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);\n      var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];\n      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size\n\n      var t = [t0]; // start the time array\n\n      var y = [y0]; // start the solution array\n\n      var deltaB = subtract(b, bp); // b - bp\n\n      var n = 0;\n      var iter = 0;\n\n      var ongoing = _createOngoing(isForwards);\n\n      var trimStep = _createTrimStep(isForwards); // iterate unitil it reaches either the final time or maximum iterations\n\n\n      while (ongoing(t[n], tf)) {\n        var k = []; // trim the time step so that it doesn't overshoot\n\n        h = trimStep(t[n], tf, h); // calculate the first value of k\n\n        k.push(f(t[n], y[n])); // calculate the rest of the values of k\n\n        for (var i = 1; i < c.length; ++i) {\n          k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));\n        } // estimate the error by comparing solutions of different orders\n\n\n        var TE = max(abs(map(multiply(deltaB, k), X => isUnit(X) ? X.value : X)));\n\n        if (TE < tol && tol / TE > 1 / 4) {\n          // push solution if within tol\n          t.push(add(t[n], h));\n          y.push(add(y[n], multiply(h, b, k)));\n          n++;\n        } // estimate the delta value that will affect the step size\n\n\n        var delta = 0.84 * (tol / TE) ** (1 / 5);\n\n        if (smaller(delta, minDelta)) {\n          delta = minDelta;\n        } else if (larger(delta, maxDelta)) {\n          delta = maxDelta;\n        }\n\n        delta = hasBigNumbers ? bignumber(delta) : delta;\n        h = multiply(h, delta);\n\n        if (maxStep && larger(abs(h), maxStep)) {\n          h = isForwards ? maxStep : unaryMinus(maxStep);\n        } else if (minStep && smaller(abs(h), minStep)) {\n          h = isForwards ? minStep : unaryMinus(minStep);\n        }\n\n        iter++;\n\n        if (iter > maxIter) {\n          throw new Error('Maximum number of iterations reached, try changing options');\n        }\n      }\n\n      return {\n        t,\n        y\n      };\n    };\n  }\n\n  function _rk23(f, tspan, y0, options) {\n    // Bogacki–Shampine method\n    // Define the butcher table\n    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];\n    var c = [null, 1 / 2, 3 / 4, 1];\n    var b = [2 / 9, 1 / 3, 4 / 9, 0];\n    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    }; // Solve an adaptive step size rk method\n\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n\n  function _rk45(f, tspan, y0, options) {\n    // Dormand Prince method\n    // Define the butcher tableau\n    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];\n    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];\n    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    }; // Solve an adaptive step size rk method\n\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n\n  function _solveODE(f, tspan, y0, opt) {\n    var method = opt.method ? opt.method : 'RK45';\n    var methods = {\n      RK23: _rk23,\n      RK45: _rk45\n    };\n\n    if (method.toUpperCase() in methods) {\n      var methodOptions = _objectSpread({}, opt); // clone the options object\n\n\n      delete methodOptions.method; // delete the method as it won't be needed\n\n      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);\n    } else {\n      // throw an error indicating there is no such method\n      var methodsWithQuotes = Object.keys(methods).map(x => \"\\\"\".concat(x, \"\\\"\")); // generates a string of methods like: \"BDF\", \"RK23\" and \"RK45\"\n\n      var availableMethodsString = \"\".concat(methodsWithQuotes.slice(0, -1).join(', '), \" and \").concat(methodsWithQuotes.slice(-1));\n      throw new Error(\"Unavailable method \\\"\".concat(method, \"\\\". Available methods are \").concat(availableMethodsString));\n    }\n  }\n\n  function _createOngoing(isForwards) {\n    // returns the correct function to test if it's still iterating\n    return isForwards ? smaller : larger;\n  }\n\n  function _createTrimStep(isForwards) {\n    var outOfBounds = isForwards ? larger : smaller;\n    return function (t, tf, h) {\n      var next = add(t, h);\n      return outOfBounds(next, tf) ? subtract(tf, t) : h;\n    };\n  }\n\n  function isNumOrBig(x) {\n    // checks if it's a number or bignumber\n    return isBigNumber(x) || isNumber(x);\n  }\n\n  function _matrixSolveODE(f, T, y0, options) {\n    // receives matrices and returns matrices\n    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);\n\n    return {\n      t: matrix(sol.t),\n      y: matrix(sol.y)\n    };\n  }\n\n  return typed('solveODE', {\n    'function, Array, Array, Object': _solveODE,\n    'function, Matrix, Matrix, Object': _matrixSolveODE,\n    'function, Array, Array': (f, T, y0) => _solveODE(f, T, y0, {}),\n    'function, Matrix, Matrix': (f, T, y0) => _matrixSolveODE(f, T, y0, {}),\n    'function, Array, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T, [y0], {});\n\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T.toArray(), [y0], {});\n\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    },\n    'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T, [y0], options);\n\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T.toArray(), [y0], options);\n\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    }\n  });\n});","map":{"version":3,"sources":["/home/radhouene/Bureau/admin/folder/VALENTANO/node_modules/mathjs/lib/esm/function/numeric/solveODE.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isUnit","isNumber","isBigNumber","factory","name","dependencies","createSolveODE","_ref","typed","add","subtract","multiply","divide","max","map","abs","isPositive","isNegative","larger","smaller","matrix","bignumber","unaryMinus","_rk","butcherTableau","f","tspan","y0","options","wrongTSpan","every","isNumOrBig","Error","t0","tf","isForwards","firstStep","undefined","maxStep","minStep","timeVars","x","steps","tol","minDelta","maxDelta","maxIter","hasBigNumbers","some","a","c","b","bp","h","t","y","deltaB","n","iter","ongoing","_createOngoing","trimStep","_createTrimStep","k","TE","X","value","delta","_rk23","_rk45","_solveODE","opt","method","methods","RK23","RK45","toUpperCase","methodOptions","methodsWithQuotes","concat","availableMethodsString","slice","join","outOfBounds","next","_matrixSolveODE","T","sol","toArray","Y"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { isUnit, isNumber, isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'solveODE';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'max', 'map', 'abs', 'isPositive', 'isNegative', 'larger', 'smaller', 'matrix', 'bignumber', 'unaryMinus'];\nexport var createSolveODE = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    subtract,\n    multiply,\n    divide,\n    max,\n    map,\n    abs,\n    isPositive,\n    isNegative,\n    larger,\n    smaller,\n    matrix,\n    bignumber,\n    unaryMinus\n  } = _ref;\n  /**\n     * Numerical Integration of Ordinary Differential Equations\n     *\n     * Two variable step methods are provided:\n     * - \"RK23\": Bogacki–Shampine method\n     * - \"RK45\": Dormand-Prince method RK5(4)7M (default)\n     *\n     * The arguments are expected as follows.\n     *\n     * - `func` should be the forcing function `f(t, y)`\n     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`\n     * - `y0` the initial state values, should be a scalar or a flat array\n     * - `options` should be an object with the following information:\n     *   - `method` ('RK45'): ['RK23', 'RK45']\n     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value\n     *   - `firstStep`: Initial step size\n     *   - `minStep`: minimum step size of the method\n     *   - `maxStep`: maximum step size of the method\n     *   - `minDelta` (0.2): minimum ratio of change for the step\n     *   - `maxDelta` (5): maximum ratio of change for the step\n     *   - `maxIter` (1e4): maximum number of iterations\n     *\n     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:\n     * - `t` an array of size `[n]`\n     * - `y` the states array can be in two ways\n     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`\n     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`\n     *\n     * Syntax:\n     *\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, y0, options)\n     *\n     * Examples:\n     *\n     *     function func(t, y) {return y}\n     *     const tspan = [0, 4]\n     *     const y0 = 1\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, [1, 2])\n     *     math.solveODE(func, tspan, y0, { method:\"RK23\", maxStep:0.1 })\n     *\n     * See also:\n     *\n     *     derivative, simplifyCore\n     *\n     * @param {function} func The forcing function f(t,y)\n     * @param {Array | Matrix} tspan The time span\n     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value\n     * @param {Object} [options] Optional configuration options\n     * @return {Object} Return an object with t and y values as arrays\n     */\n\n  function _rk(butcherTableau) {\n    // generates an adaptive runge kutta method from it's butcher tableau\n\n    return function (f, tspan, y0, options) {\n      // adaptive runge kutta methods\n      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));\n      if (wrongTSpan) {\n        throw new Error('\"tspan\" must be an Array of two numeric values or two units [tStart, tEnd]');\n      }\n      var t0 = tspan[0]; // initial time\n      var tf = tspan[1]; // final time\n      var isForwards = larger(tf, t0);\n      var firstStep = options.firstStep;\n      if (firstStep !== undefined && !isPositive(firstStep)) {\n        throw new Error('\"firstStep\" must be positive');\n      }\n      var maxStep = options.maxStep;\n      if (maxStep !== undefined && !isPositive(maxStep)) {\n        throw new Error('\"maxStep\" must be positive');\n      }\n      var minStep = options.minStep;\n      if (minStep && isNegative(minStep)) {\n        throw new Error('\"minStep\" must be positive or zero');\n      }\n      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(x => x !== undefined);\n      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {\n        throw new Error('Inconsistent type of \"t\" dependant variables');\n      }\n      var steps = 1; // divide time in this number of steps\n      var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)\n      var minDelta = options.minDelta ? options.minDelta : 0.2;\n      var maxDelta = options.maxDelta ? options.maxDelta : 5;\n      var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong\n      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);\n      var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];\n      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size\n      var t = [t0]; // start the time array\n      var y = [y0]; // start the solution array\n\n      var deltaB = subtract(b, bp); // b - bp\n\n      var n = 0;\n      var iter = 0;\n      var ongoing = _createOngoing(isForwards);\n      var trimStep = _createTrimStep(isForwards);\n      // iterate unitil it reaches either the final time or maximum iterations\n      while (ongoing(t[n], tf)) {\n        var k = [];\n\n        // trim the time step so that it doesn't overshoot\n        h = trimStep(t[n], tf, h);\n\n        // calculate the first value of k\n        k.push(f(t[n], y[n]));\n\n        // calculate the rest of the values of k\n        for (var i = 1; i < c.length; ++i) {\n          k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));\n        }\n\n        // estimate the error by comparing solutions of different orders\n        var TE = max(abs(map(multiply(deltaB, k), X => isUnit(X) ? X.value : X)));\n        if (TE < tol && tol / TE > 1 / 4) {\n          // push solution if within tol\n          t.push(add(t[n], h));\n          y.push(add(y[n], multiply(h, b, k)));\n          n++;\n        }\n\n        // estimate the delta value that will affect the step size\n        var delta = 0.84 * (tol / TE) ** (1 / 5);\n        if (smaller(delta, minDelta)) {\n          delta = minDelta;\n        } else if (larger(delta, maxDelta)) {\n          delta = maxDelta;\n        }\n        delta = hasBigNumbers ? bignumber(delta) : delta;\n        h = multiply(h, delta);\n        if (maxStep && larger(abs(h), maxStep)) {\n          h = isForwards ? maxStep : unaryMinus(maxStep);\n        } else if (minStep && smaller(abs(h), minStep)) {\n          h = isForwards ? minStep : unaryMinus(minStep);\n        }\n        iter++;\n        if (iter > maxIter) {\n          throw new Error('Maximum number of iterations reached, try changing options');\n        }\n      }\n      return {\n        t,\n        y\n      };\n    };\n  }\n  function _rk23(f, tspan, y0, options) {\n    // Bogacki–Shampine method\n\n    // Define the butcher table\n    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];\n    var c = [null, 1 / 2, 3 / 4, 1];\n    var b = [2 / 9, 1 / 3, 4 / 9, 0];\n    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _rk45(f, tspan, y0, options) {\n    // Dormand Prince method\n\n    // Define the butcher tableau\n    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];\n    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];\n    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _solveODE(f, tspan, y0, opt) {\n    var method = opt.method ? opt.method : 'RK45';\n    var methods = {\n      RK23: _rk23,\n      RK45: _rk45\n    };\n    if (method.toUpperCase() in methods) {\n      var methodOptions = _objectSpread({}, opt); // clone the options object\n      delete methodOptions.method; // delete the method as it won't be needed\n      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);\n    } else {\n      // throw an error indicating there is no such method\n      var methodsWithQuotes = Object.keys(methods).map(x => \"\\\"\".concat(x, \"\\\"\"));\n      // generates a string of methods like: \"BDF\", \"RK23\" and \"RK45\"\n      var availableMethodsString = \"\".concat(methodsWithQuotes.slice(0, -1).join(', '), \" and \").concat(methodsWithQuotes.slice(-1));\n      throw new Error(\"Unavailable method \\\"\".concat(method, \"\\\". Available methods are \").concat(availableMethodsString));\n    }\n  }\n  function _createOngoing(isForwards) {\n    // returns the correct function to test if it's still iterating\n    return isForwards ? smaller : larger;\n  }\n  function _createTrimStep(isForwards) {\n    var outOfBounds = isForwards ? larger : smaller;\n    return function (t, tf, h) {\n      var next = add(t, h);\n      return outOfBounds(next, tf) ? subtract(tf, t) : h;\n    };\n  }\n  function isNumOrBig(x) {\n    // checks if it's a number or bignumber\n    return isBigNumber(x) || isNumber(x);\n  }\n  function _matrixSolveODE(f, T, y0, options) {\n    // receives matrices and returns matrices\n    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);\n    return {\n      t: matrix(sol.t),\n      y: matrix(sol.y)\n    };\n  }\n  return typed('solveODE', {\n    'function, Array, Array, Object': _solveODE,\n    'function, Matrix, Matrix, Object': _matrixSolveODE,\n    'function, Array, Array': (f, T, y0) => _solveODE(f, T, y0, {}),\n    'function, Matrix, Matrix': (f, T, y0) => _matrixSolveODE(f, T, y0, {}),\n    'function, Array, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T, [y0], {});\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T.toArray(), [y0], {});\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    },\n    'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T, [y0], options);\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T.toArray(), [y0], options);\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    }\n  });\n});"]},"metadata":{},"sourceType":"module"}